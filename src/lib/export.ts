import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import type { DetectionLog } from "@/lib/api";

const PROJECT_NAME = "PhishGuard Ethiopia";
const TAGLINE = "Official Phishing Threat Analysis Report";
const ORGANIZATION = "PhishGuard Cyber Defense Initiative";
const FOOTER_TEXT = "© 2026 PhishGuard Ethiopia";
const FOOTER_LINE_1 = "Generated by PhishGuard Ethiopia — Confidential Security Report";
const FOOTER_LINE_2 = "For authorized use only";

export const maskSensitive = (text?: string | null) => {
  if (!text) return "";
  let masked = text.replace(/\d/g, "•");
  const emailMatch = masked.match(/([\w._%+-]+)@([\w.-]+\.[a-zA-Z]{2,})/);
  if (emailMatch) {
    const [full, local, domain] = emailMatch;
    const safeLocal = local.length <= 2 ? "•".repeat(local.length) : `${local[0]}${"•".repeat(local.length - 2)}${local[local.length - 1]}`;
    masked = masked.replace(full, `${safeLocal}@${domain}`);
  }
  return masked;
};

const formatEAT = (dateStr?: string | null) => {
  if (!dateStr) return "";
  const date = new Date(dateStr);
  return date.toLocaleString("en-US", { timeZone: "Africa/Addis_Ababa" }) + " (EAT)";
};

const riskLabel = (log: DetectionLog) => {
  if (log.riskLevel) return log.riskLevel;
  if (typeof log.riskScore === "number") {
    if (log.riskScore >= 70) return "high";
    if (log.riskScore >= 40) return "medium";
  }
  return log.result === "phishing" ? "high" : log.result === "suspicious" ? "medium" : "low";
};

const riskBadge = (level: string) => {
  if (level === "high") return { fill: [254, 226, 226], text: [220, 38, 38] };
  if (level === "medium") return { fill: [255, 237, 213], text: [217, 119, 6] };
  return { fill: [254, 249, 195], text: [161, 98, 7] };
};

const verdictBadge = (verdict: string) => {
  return verdict === "PHISHING"
    ? { fill: [254, 226, 226], text: [220, 38, 38] }
    : { fill: [220, 252, 231], text: [22, 163, 74] };
};

const addFooter = (doc: jsPDF) => {
  const pageCount = doc.getNumberOfPages();
  const pageHeight = doc.internal.pageSize.height || 297;
  for (let page = 1; page <= pageCount; page += 1) {
    doc.setPage(page);
    doc.setFontSize(8);
    doc.setTextColor(90);
    doc.text(FOOTER_LINE_1, 14, pageHeight - 18);
    doc.text(FOOTER_LINE_2, 14, pageHeight - 13);
    doc.setFontSize(9);
    doc.text(FOOTER_TEXT, 14, pageHeight - 8);
    doc.text(`Page ${page} of ${pageCount}`, 170, pageHeight - 8);
  }
};

const resolveLogo = async (logoUrl: string) => {
  const res = await fetch(logoUrl);
  const blob = await res.blob();
  return new Promise<{ dataUrl: string; type: "PNG" | "JPEG" }>((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const dataUrl = String(reader.result);
      if (dataUrl.includes("image/svg+xml")) {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement("canvas");
          const size = 64;
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext("2d");
          if (!ctx) return reject(new Error("Failed to create canvas"));
          ctx.drawImage(img, 0, 0, size, size);
          const pngData = canvas.toDataURL("image/png");
          resolve({ dataUrl: pngData, type: "PNG" });
        };
        img.onerror = () => reject(new Error("Failed to load SVG logo"));
        img.src = dataUrl;
        return;
      }
      const type = dataUrl.includes("image/png") ? "PNG" : "JPEG";
      resolve({ dataUrl, type });
    };
    reader.onerror = () => reject(new Error("Failed to load logo"));
    reader.readAsDataURL(blob);
  });
};

export const buildCsvRows = (logs: DetectionLog[], meta: { exportedBy?: string | null; scope: "all" | "single"; generatedAt: string }) =>
  logs.map((log) => ({
    report_id: `PG-${log.id.slice(0, 8)}`,
    scan_id: log.id,
    scan_type: log.inputType,
    submitted_content: maskSensitive(log.contentPreview || ""),
    verdict: log.result,
    risk_level: riskLabel(log),
    confidence: log.confidence,
    target_institution: log.institution || "Unclassified",
    indicators: (log.indicators || []).filter((i) => i.detected).map((i) => i.name).join("|") || "none",
    detected_at: formatEAT(log.createdAt),
    report_generated_at: meta.generatedAt,
    exported_by: meta.exportedBy || "Unknown",
    export_scope: meta.scope,
  }));

export const exportAllScansPdf = async (params: {
  logs: DetectionLog[];
  adminEmail?: string | null;
  logoUrl: string;
  stats: { total: number; phishing: number; safe: number };
}) => {
  const { logs, adminEmail, logoUrl, stats } = params;
  const doc = new jsPDF();

  const logoData = await resolveLogo(logoUrl).catch(() => null);
  if (logoData) {
    doc.addImage(logoData.dataUrl, logoData.type, 14, 12, 18, 18);
  }

  doc.setFontSize(16);
  doc.text(PROJECT_NAME, 36, 18);
  doc.setFontSize(11);
  doc.text(TAGLINE, 36, 24);
  doc.setFontSize(10);
  doc.text(ORGANIZATION, 36, 29);
  doc.setDrawColor(210);
  doc.line(14, 34, 196, 34);

  const generatedAt = new Date().toLocaleString();
  autoTable(doc, {
    startY: 36,
    head: [["Report Details", "Value"]],
    body: [
      ["Generated", generatedAt],
      ["Exported by", adminEmail || "Unknown"],
      ["Scope", "All scans"],
    ],
    theme: "grid",
    styles: { fontSize: 9, cellPadding: 2 },
    headStyles: { fillColor: [15, 23, 42] },
    columnStyles: { 0: { cellWidth: 35 }, 1: { cellWidth: 140 } },
  });

  const detectionRate = stats.total ? `${((stats.phishing / stats.total) * 100).toFixed(1)}%` : "0%";
  doc.setFont("helvetica", "bold");
  doc.setFontSize(12);
  const statsY = (doc as any).lastAutoTable?.finalY ? (doc as any).lastAutoTable.finalY + 6 : 52;
  doc.text(`Total scans: ${stats.total}`, 14, statsY);
  doc.text(`Threats detected: ${stats.phishing}`, 70, statsY);
  doc.text(`Detection rate: ${detectionRate}`, 140, statsY);
  doc.setFont("helvetica", "normal");
  doc.setDrawColor(220);
  doc.line(14, statsY + 4, 196, statsY + 4);

  const tableBody = logs.map((log) => [
    log.id.slice(0, 8),
    log.inputType.toUpperCase(),
    log.institution || "Unclassified",
    log.result,
    riskLabel(log),
    `${log.confidence}%`,
    formatEAT(log.createdAt),
  ]);

  autoTable(doc, {
    startY: statsY + 8,
    head: [["ID", "Type", "Targeted Institution (Detected)", "Verdict", "Risk", "Confidence", "Timestamp"]],
    body: tableBody,
    styles: { fontSize: 8, cellPadding: 3, overflow: "linebreak" },
    headStyles: { fillColor: [15, 23, 42] },
    alternateRowStyles: { fillColor: [245, 246, 248] },
    columnStyles: {
      0: { cellWidth: 18 },
      2: { cellWidth: 45 },
      6: { cellWidth: 30 },
    },
    didParseCell: (data) => {
      if (data.section === "body" && data.column.index === 3) {
        const verdict = String(data.cell.raw || "").toUpperCase();
        const badge = verdictBadge(verdict);
        data.cell.styles.fillColor = badge.fill as any;
        data.cell.styles.textColor = badge.text as any;
        data.cell.styles.fontStyle = "bold";
      }
      if (data.section === "body" && data.column.index === 4) {
        const level = String(data.cell.raw || "").toLowerCase();
        const badge = riskBadge(level);
        data.cell.styles.fillColor = badge.fill as any;
        data.cell.styles.textColor = badge.text as any;
        data.cell.styles.fontStyle = "bold";
      }
    },
  });

  addFooter(doc);

  doc.save(`phishguard-scans-${Date.now()}.pdf`);
};

export const exportSingleScanPdf = async (params: {
  log: DetectionLog;
  adminEmail?: string | null;
  logoUrl: string;
}) => {
  const { log, adminEmail, logoUrl } = params;
  const doc = new jsPDF();
  const logoData = await resolveLogo(logoUrl).catch(() => null);
  if (logoData) {
    doc.addImage(logoData.dataUrl, logoData.type, 14, 12, 18, 18);
  }

  doc.setFont("helvetica", "bold");
  doc.setFontSize(16);
  doc.text(PROJECT_NAME, 36, 18);
  doc.setFont("helvetica", "normal");
  doc.setFontSize(11);
  doc.text(TAGLINE, 36, 24);
  doc.setFontSize(10);
  doc.text(ORGANIZATION, 36, 29);
  doc.setDrawColor(210);
  doc.line(14, 34, 196, 34);

  const generatedAt = new Date().toLocaleString();
  const verdictLabel = log.result.toUpperCase();
  const level = riskLabel(log);
  const indicatorNames = (log.indicators || []).map((i) => i.name);
  const detectedIndicators = (log.indicators || []).filter((i) => i.detected).map((i) => i.name);

  let cursorY = 40;
  autoTable(doc, {
    startY: cursorY,
    head: [["Executive Summary", "Value"]],
    body: [
      ["Verdict", verdictLabel],
      ["Risk Level", level.toUpperCase()],
      ["Confidence", `${log.confidence}%`],
      ["Scan Type", log.inputType.toUpperCase()],
      ["Targeted Institution", log.institution || "Unclassified"],
      ["Scan ID", log.id],
      ["Detection Timestamp", formatEAT(log.createdAt)],
    ],
    theme: "grid",
    styles: { fontSize: 9, cellPadding: 2 },
    headStyles: { fillColor: [15, 23, 42] },
    columnStyles: { 0: { cellWidth: 45 }, 1: { cellWidth: 130 } },
    didParseCell: (data) => {
      if (data.section === "body" && data.column.index === 1) {
        if (data.row.index === 0) {
          const badge = verdictBadge(verdictLabel);
          data.cell.styles.fillColor = badge.fill as any;
          data.cell.styles.textColor = badge.text as any;
          data.cell.styles.fontStyle = "bold";
        }
        if (data.row.index === 1) {
          const badge = riskBadge(level);
          data.cell.styles.fillColor = badge.fill as any;
          data.cell.styles.textColor = badge.text as any;
          data.cell.styles.fontStyle = "bold";
        }
      }
    },
  });

  cursorY = (doc as any).lastAutoTable?.finalY ? (doc as any).lastAutoTable.finalY + 10 : cursorY + 60;
  doc.setFontSize(11);
  doc.text("Analyzed Content", 14, cursorY);
  doc.setFillColor(245, 246, 248);
  const masked = maskSensitive(log.contentPreview || "(not available)");
  doc.setFont("courier", "normal");
  doc.setFontSize(9);
  const contentLines = doc.splitTextToSize(masked, 176);
  const contentHeight = Math.max(24, contentLines.length * 4 + 6);
  doc.rect(14, cursorY + 4, 182, contentHeight, "F");
  doc.text(contentLines, 18, cursorY + 12);
  doc.setFont("helvetica", "normal");
  cursorY = cursorY + 4 + contentHeight + 10;

  doc.setFontSize(11);
  doc.text("Detection Indicators", 14, cursorY);
  doc.setFontSize(9);
  const primaryMatches = detectedIndicators.filter((name) =>
    name.toLowerCase().includes("suspicious tld") || name.toLowerCase().includes("ai classification")
  );
  const secondaryMatches = detectedIndicators.filter((name) =>
    name.toLowerCase().includes("bank lookalike") ||
    name.toLowerCase().includes("ssl") ||
    name.toLowerCase().includes("ip address") ||
    name.toLowerCase().includes("grammar") ||
    name.toLowerCase().includes("spelling")
  );
  const unused = detectedIndicators.filter(
    (name) => !primaryMatches.includes(name) && !secondaryMatches.includes(name)
  );
  const primaryList = primaryMatches.length ? primaryMatches : indicatorNames.filter((n) => n);
  const secondaryList = secondaryMatches.length ? secondaryMatches : unused;
  const indicatorBlock = [
    "Primary Risk Indicators:",
    ...(primaryList.length ? primaryList.map((name) => `- ${name}`) : ["- None observed"]),
    "",
    "Secondary / Contextual Checks:",
    ...(secondaryList.length ? secondaryList.map((name) => `- ${name}`) : ["- None observed"]),
  ];
  const indicatorLines = doc.splitTextToSize(indicatorBlock.join("\n"), 180);
  doc.text(indicatorLines, 18, cursorY + 6);
  cursorY = cursorY + 6 + indicatorLines.length * 4 + 8;

  doc.setFontSize(11);
  doc.text("AI Analysis Summary", 14, cursorY);
  doc.setFontSize(9);
  const summaryText = log.summary
    ? log.summary
    : log.result === "phishing"
      ? "The content exhibits multiple phishing characteristics targeting Ethiopian financial institutions. The detection engine flagged high-risk indicators consistent with credential harvesting attempts."
      : log.result === "suspicious"
        ? "The content contains indicators commonly associated with phishing attempts. Further verification is recommended before any action is taken."
        : "The content appears consistent with legitimate communications and lacks known phishing signals based on current checks.";
  const summaryLines = doc.splitTextToSize(summaryText, 180);
  doc.text(summaryLines, 14, cursorY + 6);
  cursorY = cursorY + 6 + summaryLines.length * 4 + 10;

  doc.setDrawColor(210);
  doc.line(14, cursorY - 4, 196, cursorY - 4);
  autoTable(doc, {
    startY: cursorY,
    head: [["Report Information", "Value"]],
    body: [
      ["Generated", generatedAt],
      ["Exported by", adminEmail || "Unknown"],
      ["Scope", "Single scan"],
      ["Data source", "PhishGuard Detection Engine"],
    ],
    theme: "grid",
    styles: { fontSize: 9, cellPadding: 2 },
    headStyles: { fillColor: [15, 23, 42] },
    columnStyles: { 0: { cellWidth: 35 }, 1: { cellWidth: 140 } },
  });

  addFooter(doc);

  doc.save(`phishguard-scan-${log.id.slice(0, 8)}.pdf`);
};
