import PDFDocument from "pdfkit";
import path from "path";

export type BulkScanLog = {
  id: string;
  inputType: "url" | "sms" | "email";
  result: "safe" | "suspicious" | "phishing";
  confidence: number;
  riskScore?: number | null;
  riskLevel?: "low" | "medium" | "high" | null;
  contentPreview?: string | null;
  createdAt: Date;
  institution?: string | null;
  summary?: string | null;
  summaryAm?: string | null;
  indicators?: Array<{ name: string; detected: boolean; severity: "low" | "medium" | "high" }>;
};

const PROJECT_NAME = "PhishGuard Ethiopia";
const REPORT_TITLE = "Official Phishing Threat Analysis Report";
const ORGANIZATION = "PhishGuard Cyber Defense Initiative";
const CLASSIFICATION = "CONFIDENTIAL";
const FOOTER_LINE_1 = "Generated by PhishGuard Ethiopia — Confidential Security Report";
const FOOTER_LINE_2 = "For authorized use only";

const FONT_PATH = path.join(process.cwd(), "assets", "fonts", "NotoSansEthiopic.ttf");

type PDFDocumentType = InstanceType<typeof PDFDocument>;

const formatEAT = (date: Date) =>
  date.toLocaleString("en-US", { timeZone: "Africa/Addis_Ababa" }) + " (EAT)";

const badgeColors = (level: string) => {
  if (level === "HIGH") return { fill: "#FEE2E2", text: "#DC2626" };
  if (level === "MEDIUM") return { fill: "#FFEDD5", text: "#D97706" };
  return { fill: "#DCFCE7", text: "#16A34A" };
};

const addFooter = (doc: PDFDocumentType) => {
  const range = doc.bufferedPageRange();
  for (let i = range.start; i < range.start + range.count; i += 1) {
    doc.switchToPage(i);
    const pageHeight = doc.page.height;
    doc.fontSize(8).fillColor("#5F6B7A");
    doc.text(FOOTER_LINE_1, 40, pageHeight - 60, { align: "left" });
    doc.text(FOOTER_LINE_2, 40, pageHeight - 48, { align: "left" });
    doc.fontSize(9).fillColor("#1F2937");
    doc.text(`Page ${i + 1} of ${range.count}`, 40, pageHeight - 34, { align: "left" });
    doc.text("PhishGuard Ethiopia • Trusted Cyber Defense", 320, pageHeight - 34, { align: "right" });
  }
};

const drawShieldIcon = (doc: PDFDocumentType, x: number, y: number) => {
  doc.save();
  doc.path(`M ${x + 12} ${y} L ${x + 26} ${y + 6} L ${x + 26} ${y + 20} L ${x + 12} ${y + 30} L ${x - 2} ${y + 20} L ${x - 2} ${y + 6} Z`)
    .fill("#0F172A");
  doc.path(`M ${x + 12} ${y + 4} L ${x + 22} ${y + 8} L ${x + 22} ${y + 18} L ${x + 12} ${y + 26} L ${x + 2} ${y + 18} L ${x + 2} ${y + 8} Z`)
    .fill("#38BDF8");
  doc.restore();
};

const drawCard = (doc: PDFDocumentType, x: number, y: number, w: number, h: number) => {
  doc.roundedRect(x, y, w, h, 6).fill("#F8FAFC");
  doc.roundedRect(x, y, w, h, 6).strokeColor("#E2E8F0").stroke();
};

const drawSectionHeader = (doc: PDFDocumentType, title: string, y: number) => {
  doc.fontSize(12).fillColor("#0F172A").text(title, 40, y);
  doc.moveTo(40, y + 16).lineTo(555, y + 16).strokeColor("#E2E8F0").stroke();
};

const sectionTitle = (doc: PDFDocumentType, title: string, y: number) => {
  doc.fontSize(12).fillColor("#111827").text(title, 40, y);
};

const ensureSpace = (doc: PDFDocumentType, cursorY: number, heightNeeded: number) => {
  if (cursorY + heightNeeded > doc.page.height - 90) {
    doc.addPage();
    return 50;
  }
  return cursorY;
};

const groupByDay = (logs: BulkScanLog[]) => {
  const counts: Record<string, number> = {};
  logs.forEach((log) => {
    const day = new Date(log.createdAt);
    const key = day.toISOString().slice(0, 10);
    counts[key] = (counts[key] || 0) + 1;
  });
  return Object.entries(counts)
    .sort(([a], [b]) => (a > b ? 1 : -1))
    .map(([date, count]) => ({ date, count }));
};

const summarizeInstitutions = (logs: BulkScanLog[]) => {
  const counts: Record<string, number> = {};
  logs.forEach((log) => {
    const key = log.institution || "Unclassified";
    counts[key] = (counts[key] || 0) + 1;
  });
  const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
  return {
    top: sorted[0]?.[0] || "Unclassified",
    topCount: sorted[0]?.[1] || 0,
    entries: sorted.slice(0, 5),
  };
};

const drawBarChart = (doc: PDFDocumentType, data: Array<{ label: string; value: number }>, x: number, y: number) => {
  const chartWidth = 240;
  const chartHeight = 120;
  doc.rect(x, y, chartWidth, chartHeight).stroke("#E5E7EB");
  if (!data.length) {
    doc.fontSize(9).fillColor("#6B7280").text("No data", x + 10, y + 50);
    return;
  }
  const maxValue = Math.max(...data.map((d) => d.value), 1);
  const barWidth = Math.max(12, chartWidth / data.length - 6);
  data.forEach((item, idx) => {
    const barHeight = Math.round((item.value / maxValue) * (chartHeight - 20));
    const barX = x + 8 + idx * (barWidth + 6);
    const barY = y + chartHeight - barHeight - 8;
    doc.rect(barX, barY, barWidth, barHeight).fill("#0EA5E9");
  });
};

export const buildBulkReportPdf = (params: {
  logs: BulkScanLog[];
  generatedAt: Date;
}) => {
  const { logs, generatedAt } = params;
  const doc = new PDFDocument({ size: "A4", margin: 40, bufferPages: true });
  doc.font(FONT_PATH);

  const total = logs.length;
  const phishing = logs.filter((l) => l.result === "phishing").length;
  const suspicious = logs.filter((l) => l.result === "suspicious").length;
  const threats = phishing;
  const safe = logs.filter((l) => l.result === "safe").length;
  const detectionRate = total ? ((threats / total) * 100).toFixed(1) : "0";

  // Header
  drawShieldIcon(doc, 40, 34);
  doc.fontSize(18).fillColor("#0F172A").text(PROJECT_NAME, 80, 40);
  doc.fontSize(12).fillColor("#1F2937").text(REPORT_TITLE, 80, 64);
  doc.fontSize(10).fillColor("#6B7280").text(ORGANIZATION, 80, 82);
  doc.roundedRect(430, 40, 120, 20, 8).fill("#0F172A");
  doc.fontSize(9).fillColor("#FFFFFF").text(CLASSIFICATION, 442, 46);
  doc.fontSize(9).fillColor("#475569").text("Report Type: Full Export", 80, 102);
  doc.fontSize(9).fillColor("#475569").text(`Generated: ${formatEAT(generatedAt)}`, 320, 102, { align: "right" });
  doc.moveTo(40, 122).lineTo(555, 122).strokeColor("#E2E8F0").stroke();

  let cursorY = 134;
  drawSectionHeader(doc, "Executive Summary", cursorY);
  cursorY += 26;

  const cardWidth = 160;
  const cardHeight = 46;
  const cardGap = 16;
  const row1Y = cursorY;
  const row2Y = row1Y + cardHeight + 12;

  drawCard(doc, 40, row1Y, cardWidth, cardHeight);
  doc.fontSize(8).fillColor("#64748B").text("Total Scans", 50, row1Y + 8);
  doc.fontSize(12).fillColor("#0F172A").text(total.toString(), 50, row1Y + 24);

  drawCard(doc, 40 + cardWidth + cardGap, row1Y, cardWidth, cardHeight);
  doc.fontSize(8).fillColor("#64748B").text("Threats Detected (Phishing)", 50 + cardWidth + cardGap, row1Y + 8);
  doc.fontSize(12).fillColor("#DC2626").text(threats.toString(), 50 + cardWidth + cardGap, row1Y + 24);

  drawCard(doc, 40 + (cardWidth + cardGap) * 2, row1Y, cardWidth, cardHeight);
  doc.fontSize(8).fillColor("#64748B").text("Detection Rate", 50 + (cardWidth + cardGap) * 2, row1Y + 8);
  doc.fontSize(12).fillColor("#0F172A").text(`${detectionRate}%`, 50 + (cardWidth + cardGap) * 2, row1Y + 24);

  drawCard(doc, 40, row2Y, cardWidth, cardHeight);
  doc.fontSize(8).fillColor("#64748B").text("Suspicious", 50, row2Y + 8);
  doc.fontSize(12).fillColor("#D97706").text(suspicious.toString(), 50, row2Y + 24);

  drawCard(doc, 40 + cardWidth + cardGap, row2Y, cardWidth, cardHeight);
  doc.fontSize(8).fillColor("#64748B").text("Safe", 50 + cardWidth + cardGap, row2Y + 8);
  doc.fontSize(12).fillColor("#16A34A").text(safe.toString(), 50 + cardWidth + cardGap, row2Y + 24);

  const overallRisk = threats / Math.max(total, 1) >= 0.25 ? "HIGH" : threats / Math.max(total, 1) >= 0.1 ? "MEDIUM" : "LOW";
  const riskBadge = badgeColors(overallRisk);
  drawCard(doc, 40 + (cardWidth + cardGap) * 2, row2Y, cardWidth, cardHeight);
  doc.fontSize(8).fillColor("#64748B").text("Overall Risk", 50 + (cardWidth + cardGap) * 2, row2Y + 8);
  doc.roundedRect(50 + (cardWidth + cardGap) * 2, row2Y + 22, 90, 18, 6).fill(riskBadge.fill);
  doc.fontSize(9).fillColor(riskBadge.text).text(overallRisk, 58 + (cardWidth + cardGap) * 2, row2Y + 26);

  cursorY = row2Y + cardHeight + 20;
  doc.roundedRect(40, cursorY, 515, 44, 8).fill(riskBadge.fill);
  doc.fillColor(riskBadge.text).fontSize(16).text(`Overall Threat Posture: ${overallRisk} RISK`, 56, cursorY + 14);
  cursorY += 62;

  drawSectionHeader(doc, "Insights & Trends", cursorY);
  cursorY += 26;

  const daily = groupByDay(logs).slice(-10);
  const institutions = summarizeInstitutions(logs);

  doc.fontSize(9).fillColor("#111827").text("Daily Scan Volume", 40, cursorY);
  drawBarChart(
    doc,
    daily.map((d) => ({ label: d.date, value: d.count })),
    40,
    cursorY + 12,
  );

  doc.fontSize(9).fillColor("#111827").text("Most Targeted Institution", 320, cursorY);
  const badge = badgeColors("HIGH");
  doc.roundedRect(320, cursorY + 18, 180, 20, 6).fill(badge.fill);
  doc.fillColor(badge.text).fontSize(10).text(`${institutions.top} (${institutions.topCount})`, 328, cursorY + 23);
  doc.fillColor("#111827");
  doc.fontSize(9).text("Top Institutions", 320, cursorY + 50);
  institutions.entries.forEach(([name, count], idx) => {
    doc.fontSize(9).fillColor("#111827").text(`${idx + 1}. ${name} — ${count}`, 320, cursorY + 66 + idx * 14);
  });

  cursorY += 160;
  cursorY = ensureSpace(doc, cursorY, 200);
  drawSectionHeader(doc, "Latest Detections", cursorY);
  cursorY += 26;

  logs.slice(0, 12).forEach((log) => {
    cursorY = ensureSpace(doc, cursorY, 28);
    const verdict = log.result.toUpperCase();
    const verdictColor = verdict === "PHISHING" ? "HIGH" : verdict === "SUSPICIOUS" ? "MEDIUM" : "LOW";
    const badgeStyle = badgeColors(verdictColor);
    doc.roundedRect(40, cursorY - 2, 90, 16, 4).fill(badgeStyle.fill);
    doc.fillColor(badgeStyle.text).fontSize(9).text(verdict, 46, cursorY);
    doc.fillColor("#111827").fontSize(9).text(`${log.inputType.toUpperCase()} • ${log.institution || "Unclassified"}`, 140, cursorY);
    doc.fillColor("#6B7280").fontSize(8).text(formatEAT(log.createdAt), 420, cursorY);
    cursorY += 20;
  });

  addFooter(doc);
  return doc;
};
