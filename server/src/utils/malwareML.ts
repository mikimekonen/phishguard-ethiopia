import fs from "fs";
import path from "path";

export type MlFeatures = {
  fileSize: number;
  fileType: number;
  entropy: number;
  isExecutable: number;
  hasBase64: number;
  hasObfuscationStrings: number;
  suspiciousStringCount: number;
  sectionCount: number;
  importCount: number;
  vtMaliciousCount: number;
  vtSuspiciousCount: number;
  numberOfEnginesScanned: number;
  reputationScore: number;
  heuristicScore: number;
  indicatorCount: number;
};

export type MlPrediction = {
  probability: number; // 0-100
  label: "Clean" | "Malware";
  explanation: string[];
};

type LabeledSample = MlFeatures & { label: 0 | 1 };

type Model = {
  featureNames: Array<keyof MlFeatures>;
  weights: number[];
  bias: number;
  mean: number[];
  std: number[];
  trainedAt: string;
};

const MODEL_PATH = process.env.MALWARE_ML_MODEL_PATH || path.join(process.cwd(), "assets", "ml", "malware-ml-model.json");
const DATASET_PATH = process.env.MALWARE_ML_DATASET_PATH || "";
let cachedModel: Model | null = null;
let modelLoaded = false;

const featureNames: Array<keyof MlFeatures> = [
  "fileSize",
  "fileType",
  "entropy",
  "isExecutable",
  "hasBase64",
  "hasObfuscationStrings",
  "suspiciousStringCount",
  "sectionCount",
  "importCount",
  "vtMaliciousCount",
  "vtSuspiciousCount",
  "numberOfEnginesScanned",
  "reputationScore",
  "heuristicScore",
  "indicatorCount",
];

const sigmoid = (value: number) => 1 / (1 + Math.exp(-value));

const normalizeVector = (vector: number[], mean: number[], std: number[]) =>
  vector.map((value, idx) => (value - mean[idx]) / (std[idx] || 1));

const parseCsv = (content: string): LabeledSample[] => {
  const lines = content.split(/\r?\n/).filter((line) => line.trim().length > 0);
  if (!lines.length) return [];
  const headers = lines[0].split(",").map((h) => h.trim());
  return lines.slice(1).map((line) => {
    const values = line.split(",").map((v) => v.trim());
    const record: Record<string, any> = {};
    headers.forEach((header, idx) => {
      record[header] = values[idx];
    });
    return coerceSample(record);
  });
};

const coerceSample = (record: Record<string, any>): LabeledSample => {
  const sample: any = {};
  featureNames.forEach((name) => {
    const value = record[name];
    sample[name] = Number.isFinite(Number(value)) ? Number(value) : 0;
  });
  const label = Number(record.label);
  sample.label = label === 1 ? 1 : 0;
  return sample as LabeledSample;
};

const loadDataset = (filePath: string): LabeledSample[] => {
  const raw = fs.readFileSync(filePath, "utf-8");
  if (filePath.endsWith(".json")) {
    const parsed = JSON.parse(raw) as Array<Record<string, any>>;
    return parsed.map((item) => coerceSample(item));
  }
  return parseCsv(raw);
};

const splitDataset = (data: LabeledSample[]) => {
  const shuffled = [...data].sort(() => Math.random() - 0.5);
  const cut = Math.max(1, Math.floor(shuffled.length * 0.8));
  return {
    train: shuffled.slice(0, cut),
    test: shuffled.slice(cut),
  };
};

const computeMeanStd = (data: LabeledSample[]) => {
  const mean = new Array(featureNames.length).fill(0);
  const std = new Array(featureNames.length).fill(0);
  data.forEach((sample) => {
    featureNames.forEach((name, idx) => {
      mean[idx] += sample[name];
    });
  });
  mean.forEach((_, idx) => {
    mean[idx] /= data.length || 1;
  });
  data.forEach((sample) => {
    featureNames.forEach((name, idx) => {
      std[idx] += Math.pow(sample[name] - mean[idx], 2);
    });
  });
  std.forEach((_, idx) => {
    std[idx] = Math.sqrt(std[idx] / (data.length || 1)) || 1;
  });
  return { mean, std };
};

const trainLogisticRegression = (data: LabeledSample[]) => {
  const { mean, std } = computeMeanStd(data);
  const weights = new Array(featureNames.length).fill(0);
  let bias = 0;
  const learningRate = 0.05;
  const epochs = 200;

  for (let epoch = 0; epoch < epochs; epoch += 1) {
    let gradW = new Array(featureNames.length).fill(0);
    let gradB = 0;
    data.forEach((sample) => {
      const vector = featureNames.map((name) => sample[name]);
      const normalized = normalizeVector(vector, mean, std);
      const linear = normalized.reduce((sum, value, idx) => sum + value * weights[idx], bias);
      const prediction = sigmoid(linear);
      const error = prediction - sample.label;
      normalized.forEach((value, idx) => {
        gradW[idx] += error * value;
      });
      gradB += error;
    });

    const n = data.length || 1;
    weights.forEach((_, idx) => {
      weights[idx] -= (learningRate * gradW[idx]) / n;
    });
    bias -= (learningRate * gradB) / n;
  }

  return { weights, bias, mean, std };
};

const evaluateModel = (model: Model, data: LabeledSample[]) => {
  let tp = 0;
  let fp = 0;
  let tn = 0;
  let fn = 0;

  data.forEach((sample) => {
    const vector = featureNames.map((name) => sample[name]);
    const normalized = normalizeVector(vector, model.mean, model.std);
    const linear = normalized.reduce((sum, value, idx) => sum + value * model.weights[idx], model.bias);
    const prediction = sigmoid(linear) >= 0.5 ? 1 : 0;
    if (prediction === 1 && sample.label === 1) tp += 1;
    if (prediction === 1 && sample.label === 0) fp += 1;
    if (prediction === 0 && sample.label === 0) tn += 1;
    if (prediction === 0 && sample.label === 1) fn += 1;
  });

  const accuracy = (tp + tn) / Math.max(1, tp + tn + fp + fn);
  const precision = tp / Math.max(1, tp + fp);
  const recall = tp / Math.max(1, tp + fn);
  return { accuracy, precision, recall };
};

const saveModel = (model: Model) => {
  fs.mkdirSync(path.dirname(MODEL_PATH), { recursive: true });
  fs.writeFileSync(MODEL_PATH, JSON.stringify(model, null, 2));
};

export const initMlModel = () => {
  if (modelLoaded) return;
  modelLoaded = true;

  if (fs.existsSync(MODEL_PATH)) {
    cachedModel = JSON.parse(fs.readFileSync(MODEL_PATH, "utf-8")) as Model;
    console.info("[malwareML] Loaded model", MODEL_PATH);
    return;
  }

  if (!DATASET_PATH || !fs.existsSync(DATASET_PATH)) {
    console.warn("[malwareML] Dataset missing, ML disabled.");
    return;
  }

  const data = loadDataset(DATASET_PATH);
  if (!data.length) {
    console.warn("[malwareML] Dataset empty, ML disabled.");
    return;
  }

  const { train, test } = splitDataset(data);
  const trained = trainLogisticRegression(train);
  const model: Model = {
    featureNames,
    weights: trained.weights,
    bias: trained.bias,
    mean: trained.mean,
    std: trained.std,
    trainedAt: new Date().toISOString(),
  };

  const metrics = evaluateModel(model, test);
  console.info("[malwareML] Training metrics", metrics);
  saveModel(model);
  cachedModel = model;
};

export const predictMalwareRisk = (features: MlFeatures): MlPrediction | null => {
  initMlModel();
  if (!cachedModel) return null;
  const model = cachedModel;

  const vector = model.featureNames.map((name) => features[name] ?? 0);
  const normalized = normalizeVector(vector, model.mean, model.std);
  const linear = normalized.reduce((sum, value, idx) => sum + value * model.weights[idx], model.bias);
  const probability = sigmoid(linear);

  const contributions = model.featureNames.map((name, idx) => ({
    name,
    score: model.weights[idx] * normalized[idx],
  }));
  const top = contributions
    .sort((a, b) => Math.abs(b.score) - Math.abs(a.score))
    .slice(0, 5)
    .map((item) => `${item.name}: ${item.score.toFixed(2)}`);

  const percent = Math.round(probability * 100);
  return {
    probability: percent,
    label: percent >= 50 ? "Malware" : "Clean",
    explanation: top,
  };
};

export const buildMlFeatures = (input: Partial<MlFeatures>): MlFeatures => ({
  fileSize: input.fileSize ?? 0,
  fileType: input.fileType ?? 0,
  entropy: input.entropy ?? 0,
  isExecutable: input.isExecutable ?? 0,
  hasBase64: input.hasBase64 ?? 0,
  hasObfuscationStrings: input.hasObfuscationStrings ?? 0,
  suspiciousStringCount: input.suspiciousStringCount ?? 0,
  sectionCount: input.sectionCount ?? 0,
  importCount: input.importCount ?? 0,
  vtMaliciousCount: input.vtMaliciousCount ?? 0,
  vtSuspiciousCount: input.vtSuspiciousCount ?? 0,
  numberOfEnginesScanned: input.numberOfEnginesScanned ?? 0,
  reputationScore: input.reputationScore ?? 0,
  heuristicScore: input.heuristicScore ?? 0,
  indicatorCount: input.indicatorCount ?? 0,
});
