import PDFDocument from "pdfkit";
import path from "path";
import type { MalwareScanRecord } from "../types/malware";

const FONT_PATH = path.join(process.cwd(), "assets", "fonts", "NotoSansEthiopic.ttf");
const PROJECT_NAME = "PhishGuard Ethiopia";
const REPORT_TITLE = "Malware Intelligence Summary";

const escapeCsv = (value: string | number | null | undefined) => {
  const str = String(value ?? "");
  if (str.includes(",") || str.includes("\n") || str.includes("\"")) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
};

export const buildMalwareCsv = (records: MalwareScanRecord[]) => {
  const headers = [
    "scan_id",
    "verdict",
    "confidence_score",
    "malware_family",
    "behavior_summary",
    "target_platform",
    "delivery_method",
    "impersonated_institution",
    "first_seen",
    "last_seen",
  ];

  const rows = records.map((scan) => [
    scan.id,
    scan.verdict,
    scan.confidenceScore,
    scan.malwareFamily ?? "",
    scan.behaviorSummary ?? "",
    scan.targetPlatform ?? "",
    scan.deliveryMethod ?? "",
    scan.impersonatedInstitution ?? "",
    scan.firstSeen?.toISOString() ?? "",
    scan.lastSeen?.toISOString() ?? "",
  ]);

  return [headers, ...rows].map((row) => row.map(escapeCsv).join(",")).join("\n");
};

export const buildMalwarePdf = (records: MalwareScanRecord[]) => {
  const doc = new PDFDocument({ size: "A4", margin: 40, bufferPages: true });
  doc.font(FONT_PATH);

  doc.fontSize(18).fillColor("#0F172A").text(PROJECT_NAME, 40, 40);
  doc.fontSize(12).fillColor("#1F2937").text(REPORT_TITLE, 40, 66);
  doc.fontSize(9).fillColor("#6B7280").text(`Generated: ${new Date().toISOString()}`, 40, 84);
  doc.moveTo(40, 100).lineTo(555, 100).strokeColor("#E2E8F0").stroke();

  let y = 120;
  doc.fontSize(10).fillColor("#0F172A").text("Recent Malware Intelligence", 40, y);
  y += 18;

  records.slice(0, 40).forEach((scan) => {
    if (y > 760) {
      doc.addPage();
      y = 40;
    }
    doc.fontSize(9).fillColor("#111827").text(`Verdict: ${scan.verdict.toUpperCase()}`, 40, y);
    doc.text(`Confidence: ${scan.confidenceScore}%`, 200, y);
    doc.text(`Family: ${scan.malwareFamily ?? "Unknown"}`, 340, y);
    y += 14;
    doc.fillColor("#6B7280").text(`Summary: ${scan.behaviorSummary ?? "No summary available"}`, 40, y, { width: 500 });
    y += 18;
    doc.moveTo(40, y).lineTo(555, y).strokeColor("#E2E8F0").stroke();
    y += 10;
  });

  return doc;
};

const parseJson = <T>(value: string | null, fallback: T) => {
  if (!value) return fallback;
  try {
    return JSON.parse(value) as T;
  } catch {
    return fallback;
  }
};

export const buildMalwareDetailPdf = (scan: MalwareScanRecord) => {
  const doc = new PDFDocument({ size: "A4", margin: 40, bufferPages: true });
  doc.font(FONT_PATH);

  const threatTags = parseJson<string[]>(scan.threatTagsJson, []);
  const suspiciousStrings = parseJson<string[]>(scan.suspiciousStringsJson, []);
  const detectionEngines = parseJson<Array<{ engine: string; category: string; result: string | null }>>(
    scan.detectionEnginesJson,
    [],
  );
  const iocs = parseJson<Record<string, unknown> | null>(scan.iocsJson, null);
  const staticFeatures = parseJson<Record<string, unknown> | null>(scan.staticFeaturesJson, null);
  const dynamicFeatures = parseJson<Record<string, unknown> | null>(scan.dynamicFeaturesJson, null);

  doc.fontSize(18).fillColor("#0F172A").text(PROJECT_NAME, 40, 40);
  doc.fontSize(12).fillColor("#1F2937").text("Malware Intelligence Detail", 40, 66);
  doc.fontSize(9).fillColor("#6B7280").text(`Generated: ${new Date().toISOString()}`, 40, 84);
  doc.moveTo(40, 100).lineTo(555, 100).strokeColor("#E2E8F0").stroke();

  let y = 120;
  const line = (label: string, value: string) => {
    doc.fillColor("#111827").fontSize(9).text(`${label}: `, 40, y, { continued: true });
    doc.fillColor("#374151").text(value || "—");
    y += 14;
  };

  doc.fontSize(11).fillColor("#0F172A").text("Basic Identification", 40, y);
  y += 16;
  line("Filename", scan.fileName ?? "Unknown");
  line("Verdict", scan.verdict.toUpperCase());
  line("Confidence", `${scan.confidenceScore}%`);
  line("Risk Score", `${scan.riskScore ?? 0}%`);
  line("Malware Type", scan.malwareType ?? "—");
  line("Malware Family", scan.malwareFamily ?? "—");
  line("Threat Label", scan.threatLabel ?? "—");
  line("Threat Tags", threatTags.length ? threatTags.join(", ") : "—");
  y += 6;

  doc.fontSize(11).fillColor("#0F172A").text("Hashes & Metadata", 40, y);
  y += 16;
  line("SHA256", scan.hashSha256);
  line("SHA1", scan.sha1 ?? "—");
  line("MD5", scan.md5 ?? "—");
  line("File Size", scan.fileSize ? `${scan.fileSize} bytes` : "—");
  line("File Type", scan.fileTypeDescription ?? scan.fileType ?? "—");
  line("Detected At", scan.detectionTimestamp?.toISOString() ?? "—");
  y += 6;

  doc.fontSize(11).fillColor("#0F172A").text("Behavior & Impact", 40, y);
  y += 16;
  doc.fontSize(9).fillColor("#374151").text(`Behavior: ${scan.behaviorDescription ?? "—"}`, 40, y, { width: 520 });
  y += 28;
  doc.text(`Impact: ${scan.impactDescription ?? "—"}`, 40, y, { width: 520 });
  y += 28;
  doc.text(`Mitigation: ${scan.mitigationSuggestions ?? "—"}`, 40, y, { width: 520 });
  y += 28;
  doc.text(`መግለጫ (AM): ${scan.descriptionAm ?? "—"}`, 40, y, { width: 520 });
  y += 28;

  doc.fontSize(11).fillColor("#0F172A").text("Static Features", 40, y);
  y += 16;
  line("Entropy", scan.entropy ? scan.entropy.toFixed(2) : "—");
  line("Suspicious Strings", suspiciousStrings.length ? suspiciousStrings.slice(0, 12).join(", ") : "—");
  doc.text(`Static Features JSON: ${staticFeatures ? JSON.stringify(staticFeatures) : "—"}`, 40, y, { width: 520 });
  y += 28;

  doc.fontSize(11).fillColor("#0F172A").text("Dynamic Features", 40, y);
  y += 16;
  doc.text(`Dynamic Features JSON: ${dynamicFeatures ? JSON.stringify(dynamicFeatures) : "—"}`, 40, y, { width: 520 });
  y += 28;

  doc.fontSize(11).fillColor("#0F172A").text("IOCs", 40, y);
  y += 16;
  doc.text(iocs ? JSON.stringify(iocs) : "—", 40, y, { width: 520 });
  y += 28;

  doc.fontSize(11).fillColor("#0F172A").text("Detection Engines", 40, y);
  y += 16;
  if (detectionEngines.length) {
    detectionEngines.slice(0, 25).forEach((engine) => {
      doc.fontSize(8).fillColor("#374151").text(`${engine.engine}: ${engine.category} ${engine.result ?? ""}`.trim(), 40, y);
      y += 12;
      if (y > 760) {
        doc.addPage();
        y = 40;
      }
    });
  } else {
    doc.fontSize(9).fillColor("#6B7280").text("No engine details available.", 40, y);
  }

  return doc;
};
