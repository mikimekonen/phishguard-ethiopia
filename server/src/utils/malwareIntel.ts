import crypto from "crypto";
import fs from "fs";
import path from "path";
import axios from "axios";
import FormData from "form-data";
import AdmZip from "adm-zip";
import { buildMlFeatures, predictMalwareRisk } from "./malwareML";
import { evaluateVerdict } from "./verdictEngine";

export type MalwareVerdict = "CLEAN" | "SUSPICIOUS" | "MALICIOUS" | "UNKNOWN";

export type MalwareIntelResult = {
  found: boolean;
  verdict: MalwareVerdict;
  confidence: number; // 0-1 for compatibility with existing API
  maliciousCount?: number;
  suspiciousCount?: number;
  harmlessCount?: number;
  undetectedCount?: number;
  riskScore?: number;
  intelProvider?: string;
  malwareFamily?: string;
  malwareType?: string;
  threatLabel?: string;
  threatTags?: string[];
  md5?: string;
  sha1?: string;
  fileSize?: number;
  fileTypeDescription?: string;
  entropy?: number;
  suspiciousStrings?: string[];
  detectionEngines?: Array<{ engine: string; category: string; result: string | null }>;
  detectionTimestamp?: Date | null;
  behaviorDescription?: string;
  impactDescription?: string;
  mitigationSuggestions?: string;
  descriptionAm?: string;
  iocs?: Record<string, unknown>;
  staticFeatures?: Record<string, unknown>;
  dynamicFeatures?: Record<string, unknown>;
  behaviorSummary?: string;
  classification?: string;
  behaviorIndicators?: string[];
  targetPlatform?: string;
  firstSeen?: Date | null;
  lastSeen?: Date | null;
  provider?: string;
};

export type ScanOutput = {
  status: "Clean" | "Suspicious" | "Malware Detected" | "Unknown";
  verdict: MalwareVerdict;
  confidence: number; // 0-100
  analysisType: "external" | "heuristic" | "combined";
  fileType: string;
  reasons: string[];
  malwareFamily?: string;
  malwareType?: string;
  threatLabel?: string;
  threatTags?: string[];
  md5?: string;
  sha1?: string;
  fileSize?: number;
  fileTypeDescription?: string;
  entropy?: number;
  suspiciousStrings?: string[];
  detectionEngines?: Array<{ engine: string; category: string; result: string | null }>;
  detectionTimestamp?: Date | null;
  behaviorDescription?: string;
  impactDescription?: string;
  mitigationSuggestions?: string;
  descriptionAm?: string;
  iocs?: Record<string, unknown>;
  staticFeatures?: Record<string, unknown>;
  dynamicFeatures?: Record<string, unknown>;
  maliciousCount: number;
  suspiciousCount: number;
  harmlessCount: number;
  undetectedCount: number;
  riskScore: number;
  intelProvider: string;
  engineResults: {
    provider: string;
    malicious: number;
    suspicious: number;
  };
};

type ProviderName = "virustotal" | "hybrid" | "hybrid-analysis" | "opswat";

type ProviderResult = {
  provider: string;
  malicious: number;
  suspicious: number;
  harmless: number;
  undetected: number;
  riskScore: number;
  verdict: MalwareVerdict;
  raw: unknown;
  malwareFamily?: string;
  malwareType?: string;
  threatLabel?: string;
  threatTags?: string[];
  md5?: string;
  sha1?: string;
  fileSize?: number;
  fileTypeDescription?: string;
  detectionEngines?: Array<{ engine: string; category: string; result: string | null }>;
  detectionTimestamp?: Date | null;
};

type IntelCounts = {
  malicious: number;
  suspicious: number;
  harmless: number;
  undetected: number;
};

const BASE_URL = process.env.MALWARE_INTEL_BASE_URL || "";
const API_KEY = process.env.MALWARE_INTEL_API_KEY || "";
const REQUEST_TIMEOUT_MS = Number(process.env.MALWARE_INTEL_TIMEOUT_MS || 20000);
const MAX_POLL_ATTEMPTS = Number(process.env.MALWARE_INTEL_POLL_ATTEMPTS || 6);
const POLL_DELAY_MS = Number(process.env.MALWARE_INTEL_POLL_DELAY_MS || 1500);
const SANDBOX_PROVIDER = (process.env.MALWARE_SANDBOX_PROVIDER || "").toLowerCase();
const SANDBOX_ON_CLEAN = process.env.MALWARE_SANDBOX_ON_CLEAN === "true";

const DEFAULT_BASE_URLS: Record<ProviderName, string> = {
  virustotal: "https://www.virustotal.com/api/v3",
  hybrid: "https://www.hybrid-analysis.com/api/v2",
  "hybrid-analysis": "https://www.hybrid-analysis.com/api/v2",
  opswat: "https://api.metadefender.com/v4",
};

const MALWARE_TYPE_LIBRARY: Record<string, {
  behavior: string;
  impact: string;
  mitigation: string;
  am: string;
}> = {
  trojan: {
    behavior: "Masquerades as legitimate software to deliver malicious payloads and enable remote access.",
    impact: "Credential theft, unauthorized access, and secondary malware downloads.",
    mitigation: "Isolate the host, remove the file, rotate credentials, and run endpoint scans.",
    am: "እንደ የተለመደ ሶፍትዌር ተሸፍኖ ይታያል፣ ክፍት መድረሻ ያቋቋማል እና ተጨማሪ ማልዌር ያወርዳል።",
  },
  ransomware: {
    behavior: "Encrypts files and demands payment to restore access.",
    impact: "Data loss, service disruption, and financial extortion.",
    mitigation: "Isolate systems, restore from backups, and rotate credentials.",
    am: "ፋይሎችን ይጠብቃል እና መክፈቻ ክፍያ ይጠይቃል።",
  },
  worm: {
    behavior: "Self-replicates and spreads across networks without user interaction.",
    impact: "Rapid propagation, resource exhaustion, and lateral movement.",
    mitigation: "Segment networks, patch systems, and block suspicious traffic.",
    am: "ራሱን በራሱ ይባዛ እና በኔትወርክ ይተላለፋል።",
  },
  spyware: {
    behavior: "Monitors activity and captures sensitive information silently.",
    impact: "Privacy loss and credential theft.",
    mitigation: "Remove the malware and reset passwords; enable endpoint protection.",
    am: "ተጠቃሚ እንቅስቃሴን በስተጀርባ ይከታተላል።",
  },
  virus: {
    behavior: "Infects files and spreads when infected files are executed.",
    impact: "File corruption and system instability.",
    mitigation: "Remove infected files and run full antivirus scans.",
    am: "ፋይሎችን ይያዛል እና ሲከፈቱ ይተላለፋል።",
  },
  default: {
    behavior: "Malicious behavior detected but specific type is unknown.",
    impact: "Potential system compromise or data exposure.",
    mitigation: "Isolate the host and perform full incident response.",
    am: "የማልዌር እንቅስቃሴ ተገኝቷል፣ ነገር ግን አይነቱ አልተለየም።",
  },
};

const resolveTypeProfile = (value?: string | null) => {
  const key = String(value || "").toLowerCase();
  if (key.includes("ransom")) return MALWARE_TYPE_LIBRARY.ransomware;
  if (key.includes("trojan")) return MALWARE_TYPE_LIBRARY.trojan;
  if (key.includes("worm")) return MALWARE_TYPE_LIBRARY.worm;
  if (key.includes("spy")) return MALWARE_TYPE_LIBRARY.spyware;
  if (key.includes("virus")) return MALWARE_TYPE_LIBRARY.virus;
  return MALWARE_TYPE_LIBRARY.default;
};

const getProviders = () =>
  (process.env.MALWARE_INTEL_PROVIDER || "virustotal")
    .split(",")
    .map((value) => value.trim().toLowerCase())
    .filter(Boolean) as ProviderName[];

const getBaseUrl = (provider: ProviderName) => {
  const upper = provider.replace(/[-\s]/g, "_").toUpperCase();
  const envUrl = process.env[`MALWARE_INTEL_BASE_URL_${upper}`];
  return envUrl || BASE_URL || DEFAULT_BASE_URLS[provider];
};

const getApiKey = (provider: ProviderName) => {
  const upper = provider.replace(/[-\s]/g, "_").toUpperCase();
  const envKey = process.env[`MALWARE_INTEL_API_KEY_${upper}`];
  return envKey || API_KEY;
};

const normalizePercent = (value: number) => Math.max(0, Math.min(100, Math.round(value)));

const computeRiskScore = (counts: IntelCounts) => {
  const total = counts.malicious + counts.suspicious + counts.harmless + counts.undetected;
  if (total === 0) return 0;
  const weighted = counts.malicious * 1.0 + counts.suspicious * 0.5 + counts.undetected * 0.1;
  return normalizePercent((weighted / total) * 100);
};

const evaluateVerdictFromCounts = (counts: IntelCounts): MalwareVerdict => {
  // Explicit mapping based on real external intel counts.
  if (counts.malicious > 0) return "MALICIOUS";
  if (counts.malicious === 0 && counts.suspicious > 0) return "SUSPICIOUS";
  return "CLEAN";
};

export const analyzeMalwareResult = (apiResult: any, intelProvider = "VirusTotal") => {
  const stats =
    apiResult?.data?.attributes?.stats ||
    apiResult?.data?.attributes?.last_analysis_stats ||
    null;

  const threatClassification = apiResult?.data?.attributes?.popular_threat_classification || null;
  const threatLabel = threatClassification?.suggested_threat_label || null;
  const threatCategory = Array.isArray(threatClassification?.popular_threat_category)
    ? threatClassification.popular_threat_category[0]?.value || null
    : null;
  const threatTags = Array.isArray(apiResult?.data?.attributes?.tags)
    ? apiResult.data.attributes.tags
    : [];
  const attributes = apiResult?.data?.attributes || {};
  const detectionTimestamp = attributes?.last_analysis_date
    ? new Date(attributes.last_analysis_date * 1000)
    : null;
  const detectionEngines = attributes?.last_analysis_results
    ? Object.entries(attributes.last_analysis_results).map(([engine, result]: any) => ({
        engine,
        category: String(result?.category || ""),
        result: result?.result ?? null,
      }))
    : [];
  const typeProfile = resolveTypeProfile(threatCategory || threatLabel || attributes?.type_description);
  const iocs = {
    md5: attributes?.md5 || null,
    sha1: attributes?.sha1 || null,
    sha256: attributes?.sha256 || null,
    tags: threatTags,
  };

  if (!stats || typeof stats !== "object") {
    console.warn("[malwareIntel] Intel response missing stats", { intelProvider });
    return {
      counts: { malicious: 0, suspicious: 0, harmless: 0, undetected: 0 },
      riskScore: 0,
      verdict: "UNKNOWN" as MalwareVerdict,
      intelProvider,
      threatLabel: threatLabel || undefined,
      malwareType: threatCategory || undefined,
      threatTags: threatTags.length ? threatTags : undefined,
      md5: attributes?.md5 || undefined,
      sha1: attributes?.sha1 || undefined,
      fileSize: attributes?.size || undefined,
      fileTypeDescription: attributes?.type_description || undefined,
      detectionEngines: detectionEngines.length ? detectionEngines : undefined,
      detectionTimestamp,
      behaviorDescription: typeProfile.behavior,
      impactDescription: typeProfile.impact,
      mitigationSuggestions: typeProfile.mitigation,
      descriptionAm: typeProfile.am,
      iocs,
      staticFeatures: undefined,
      dynamicFeatures: undefined,
    };
  }

  const counts: IntelCounts = {
    malicious: Number(stats.malicious || 0),
    suspicious: Number(stats.suspicious || 0),
    harmless: Number(stats.harmless || 0),
    undetected: Number(stats.undetected || 0),
  };

  const riskScore = computeRiskScore(counts);
  const verdict = evaluateVerdictFromCounts(counts);

  // Debug logging required by the task.
  console.info("[malwareIntel] Raw intel response", apiResult);
  console.info("[malwareIntel] Computed riskScore", { riskScore, counts });
  console.info("[malwareIntel] Final verdict", { verdict, intelProvider });

  return {
    counts,
    riskScore,
    verdict,
    intelProvider,
    threatLabel: threatLabel || undefined,
    malwareType: threatCategory || undefined,
    threatTags: threatTags.length ? threatTags : undefined,
    md5: attributes?.md5 || undefined,
    sha1: attributes?.sha1 || undefined,
    fileSize: attributes?.size || undefined,
    fileTypeDescription: attributes?.type_description || undefined,
    detectionEngines: detectionEngines.length ? detectionEngines : undefined,
    detectionTimestamp,
    behaviorDescription: typeProfile.behavior,
    impactDescription: typeProfile.impact,
    mitigationSuggestions: typeProfile.mitigation,
    descriptionAm: typeProfile.am,
    iocs,
    staticFeatures: undefined,
    dynamicFeatures: undefined,
  };
};

const fileTypeToNumber = (type: string) => {
  const mapping: Record<string, number> = {
    executable: 5,
    script: 4,
    document: 3,
    pdf: 3,
    image: 2,
    archive: 2,
    unknown: 1,
  };
  return mapping[type] || 0;
};

export const computeSha256 = (buffer: Buffer) =>
  crypto.createHash("sha256").update(buffer).digest("hex");

const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

const computeEntropy = (buffer: Buffer) => {
  if (!buffer.length) return 0;
  const counts = new Array<number>(256).fill(0);
  for (const byte of buffer) counts[byte] += 1;
  let entropy = 0;
  for (const count of counts) {
    if (!count) continue;
    const p = count / buffer.length;
    entropy -= p * Math.log2(p);
  }
  return entropy;
};

const containsSuspiciousStrings = (content: string) => {
  const lower = content.toLowerCase();
  const indicators = ["powershell", "cmd.exe", "wget ", "curl ", "frombase64string", "eval("];
  return indicators.filter((term) => lower.includes(term));
};

const containsBase64Blocks = (content: string) => /[A-Za-z0-9+/]{80,}={0,2}/.test(content);

const detectBinaryType = (buffer: Buffer) => {
  const mz = buffer.length > 2 && buffer[0] === 0x4d && buffer[1] === 0x5a;
  const elf = buffer.length > 4 && buffer[0] === 0x7f && buffer[1] === 0x45 && buffer[2] === 0x4c && buffer[3] === 0x46;
  const macho = buffer.length > 4 && (
    (buffer[0] === 0xfe && buffer[1] === 0xed && buffer[2] === 0xfa && buffer[3] === 0xce) ||
    (buffer[0] === 0xfe && buffer[1] === 0xed && buffer[2] === 0xfa && buffer[3] === 0xcf) ||
    (buffer[0] === 0xcf && buffer[1] === 0xfa && buffer[2] === 0xed && buffer[3] === 0xfe) ||
    (buffer[0] === 0xce && buffer[1] === 0xfa && buffer[2] === 0xed && buffer[3] === 0xfe) ||
    (buffer[0] === 0xca && buffer[1] === 0xfe && buffer[2] === 0xba && buffer[3] === 0xbe)
  );
  return { mz, elf, macho };
};

const detectFileType = (filePath: string, buffer: Buffer) => {
  const ext = path.extname(filePath).toLowerCase();
  if (buffer.slice(0, 4).toString("latin1") === "%PDF") return "pdf";
  if (buffer.slice(0, 4).toString("latin1") === "PK\u0003\u0004") return "archive";
  if (buffer.slice(0, 2).toString("hex") === "ffd8") return "image";
  if (buffer.slice(0, 8).toString("hex") === "89504e470d0a1a0a") return "image";
  if (buffer.slice(0, 3).toString("latin1") === "GIF") return "image";
  if ([".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp", ".svg"].includes(ext)) return "image";
  if ([".js", ".ts", ".ps1", ".vbs", ".bat", ".sh", ".py"].includes(ext)) return "script";
  if ([".docx", ".doc", ".xlsx", ".pptx"].includes(ext)) return "document";
  if ([".zip", ".rar", ".7z", ".tar", ".gz"].includes(ext)) return "archive";
  if ([".exe", ".dll", ".bin", ".apk"].includes(ext)) return "executable";
  return "unknown";
};

const getPeSectionCount = (buffer: Buffer) => {
  if (buffer.length < 0x40) return null;
  const peOffset = buffer.readUInt32LE(0x3c);
  if (!peOffset || peOffset + 6 >= buffer.length) return null;
  const sig = buffer.slice(peOffset, peOffset + 4).toString("latin1");
  if (sig !== "PE\u0000\u0000") return null;
  return buffer.readUInt16LE(peOffset + 6);
};

const MAX_ARCHIVE_ENTRIES = 50;
const MAX_ARCHIVE_ENTRY_BYTES = 2 * 1024 * 1024;

const inspectArchive = (buffer: Buffer) => {
  try {
    const zip = new AdmZip(buffer);
    const entries = zip.getEntries().slice(0, MAX_ARCHIVE_ENTRIES);
    let suspiciousEntries = 0;
    let encryptedEntries = 0;
    let maxEntryScore = 0;
    const reasons: string[] = [];

    entries.forEach((entry: AdmZip.IZipEntry) => {
      if (entry.isDirectory) return;
      const flags = (entry.header as any)?.flags as number | undefined;
      if (typeof flags === "number" && (flags & 0x1) === 0x1) {
        encryptedEntries += 1;
        return;
      }
      const entrySize = (entry.header as any)?.size as number | undefined;
      if (typeof entrySize === "number" && entrySize > MAX_ARCHIVE_ENTRY_BYTES) {
        return;
      }
      try {
        const entryBuffer = entry.getData();
        const entryHeuristic = runHeuristics(entryBuffer, entry.entryName);
        maxEntryScore = Math.max(maxEntryScore, entryHeuristic.confidence);
        if (entryHeuristic.confidence >= 45) suspiciousEntries += 1;
      } catch {
        encryptedEntries += 1;
      }
    });

    if (entries.length) {
      reasons.push(`Archive inspected: ${entries.length} files (showing up to ${MAX_ARCHIVE_ENTRIES}).`);
    }
    if (encryptedEntries > 0) {
      reasons.push("Encrypted archive entries detected.");
    }
    if (suspiciousEntries > 0) {
      reasons.push(`${suspiciousEntries} archive entries flagged by static checks.`);
    }

    return { entries: entries.length, suspiciousEntries, encryptedEntries, maxEntryScore, reasons };
  } catch (error) {
    return { entries: 0, suspiciousEntries: 0, encryptedEntries: 0, maxEntryScore: 0, reasons: ["Archive inspection failed."] };
  }
};

const runHeuristics = (buffer: Buffer, filePath: string) => {
  const sample = buffer.subarray(0, Math.min(buffer.length, 2 * 1024 * 1024));
  const content = sample.toString("latin1");
  const type = detectFileType(filePath, sample);
  const { mz, elf, macho } = detectBinaryType(sample);
  const suspiciousStrings = containsSuspiciousStrings(content);
  const hasBase64 = containsBase64Blocks(content);
  const entropy = computeEntropy(sample);
  const peSections = mz ? getPeSectionCount(sample) : null;

  const reasons: string[] = [];
  let score = 0;
  reasons.push(`File type detected: ${type}.`);

  if (mz || elf || macho) {
    if (type !== "document" && type !== "image") {
      score += 35;
      reasons.push("Executable header detected.");
    }
  }

  if (type === "executable" && peSections !== null && peSections <= 3 && entropy > 7.5) {
    score += 40;
    reasons.push("Packed executable characteristics (few sections + high entropy).");
  }

  if (suspiciousStrings.length) {
    if (type === "script") {
      score += Math.min(50, suspiciousStrings.length * 15);
      reasons.push(`Suspicious script keywords: ${suspiciousStrings.join(", ")}.`);
    } else if (type === "executable") {
      score += Math.min(30, suspiciousStrings.length * 10);
      reasons.push(`Suspicious executable strings: ${suspiciousStrings.join(", ")}.`);
    }
  }

  if (hasBase64) {
    if (type === "script") {
      score += 20;
      reasons.push("Base64 block in script content.");
    } else if (type === "executable") {
      score += 25;
      reasons.push("Base64 block in executable content.");
    }
  }

  if (entropy > 7.5) {
    if (type === "executable") {
      score += 35;
      reasons.push("High entropy in executable suggests packing/obfuscation.");
    } else if (type === "script") {
      score += 10;
      reasons.push("High entropy in script content.");
    }
  }

  const confidence = normalizePercent(score);
  const malicious = confidence >= 71 ? 1 : 0;
  const suspicious = confidence >= 30 && confidence < 71 ? 1 : 0;

  if (reasons.length === 1) {
    reasons.push("No static indicators detected.");
    console.info("[malwareIntel] Heuristics found no indicators.");
  } else {
    console.info("[malwareIntel] Heuristic indicators detected.", { type, entropy, peSections });
  }

  const importCount = type === "executable"
    ? (content.match(/\.dll/gi) || []).length
    : 0;

  return {
    fileType: type,
    confidence,
    reasons,
    suspiciousStrings,
    metrics: {
      entropy,
      hasBase64,
      suspiciousStringCount: suspiciousStrings.length,
      sectionCount: peSections || 0,
      importCount,
      indicatorCount: reasons.length,
      isExecutable: mz || elf || macho,
    },
    engineResults: { provider: "heuristic", malicious, suspicious },
  };
};

const pollVirusTotalAnalysis = async (analysisId: string, baseUrl: string, apiKey: string) => {
  const url = `${baseUrl}/analyses/${analysisId}`;
  for (let attempt = 0; attempt < MAX_POLL_ATTEMPTS; attempt += 1) {
    console.info(`[malwareIntel] VirusTotal poll attempt ${attempt + 1}/${MAX_POLL_ATTEMPTS}`);
    const res = await axios.get(url, {
      headers: { "x-apikey": apiKey, Accept: "application/json" },
      timeout: REQUEST_TIMEOUT_MS,
      validateStatus: () => true,
    });
    console.debug("[malwareIntel] VirusTotal analysis response", res.data);
    if (res.status < 200 || res.status >= 300) {
      throw new Error(`VirusTotal analysis failed (${res.status})`);
    }
    const status = res.data?.data?.attributes?.status;
    if (status === "completed") return res.data;
    await delay(POLL_DELAY_MS);
  }
  throw new Error("VirusTotal analysis polling timed out");
};

const scanVirusTotal = async (filePath: string): Promise<ProviderResult> => {
  const baseUrl = getBaseUrl("virustotal");
  const apiKey = getApiKey("virustotal");
  if (!apiKey) throw new Error("VirusTotal API key missing");

  const buffer = fs.readFileSync(filePath);
  const form = new FormData();
  form.append("file", buffer, { filename: path.basename(filePath) });

  console.info("[malwareIntel] VirusTotal upload", `${baseUrl}/files`);
  const upload = await axios.post(`${baseUrl}/files`, form, {
    headers: { ...form.getHeaders(), "x-apikey": apiKey, Accept: "application/json" },
    timeout: REQUEST_TIMEOUT_MS,
    validateStatus: () => true,
  });
  console.debug("[malwareIntel] VirusTotal upload response", upload.data);
  if (upload.status < 200 || upload.status >= 300) {
    throw new Error(`VirusTotal upload failed (${upload.status})`);
  }

  const analysisId = upload.data?.data?.id;
  if (!analysisId) throw new Error("VirusTotal missing analysis id");

  const analysis = await pollVirusTotalAnalysis(analysisId, baseUrl, apiKey);
  const intel = analyzeMalwareResult(analysis, "VirusTotal");
  return {
    provider: "VirusTotal",
    malicious: intel.counts.malicious,
    suspicious: intel.counts.suspicious,
    harmless: intel.counts.harmless,
    undetected: intel.counts.undetected,
    riskScore: intel.riskScore,
    verdict: intel.verdict,
    raw: analysis,
    malwareFamily: intel.threatLabel || analysis?.data?.attributes?.popular_threat_classification?.suggested_threat_label,
    malwareType: intel.malwareType,
    threatLabel: intel.threatLabel,
    threatTags: intel.threatTags,
    md5: intel.md5,
    sha1: intel.sha1,
    fileSize: intel.fileSize,
    fileTypeDescription: intel.fileTypeDescription,
    detectionEngines: intel.detectionEngines,
    detectionTimestamp: intel.detectionTimestamp,
  };
};

const scanHybridAnalysis = async (filePath: string): Promise<ProviderResult> => {
  const baseUrl = getBaseUrl("hybrid-analysis");
  const apiKey = getApiKey("hybrid-analysis");
  if (!apiKey) throw new Error("Hybrid Analysis API key missing");

  const form = new FormData();
  form.append("file", fs.createReadStream(filePath));

  console.info("[malwareIntel] Hybrid Analysis submit", `${baseUrl}/submit/file`);
  const submit = await axios.post(`${baseUrl}/submit/file`, form, {
    headers: { ...form.getHeaders(), "api-key": apiKey, "user-agent": "Falcon Sandbox", Accept: "application/json" },
    timeout: REQUEST_TIMEOUT_MS,
    validateStatus: () => true,
  });
  console.debug("[malwareIntel] Hybrid Analysis submit response", submit.data);
  if (submit.status < 200 || submit.status >= 300) {
    throw new Error(`Hybrid Analysis submit failed (${submit.status})`);
  }

  const sha256 = submit.data?.sha256 || submit.data?.data?.sha256;
  if (!sha256) throw new Error("Hybrid Analysis missing sha256");

  console.info("[malwareIntel] Hybrid Analysis report", `${baseUrl}/report/${sha256}/summary`);
  const report = await axios.get(`${baseUrl}/report/${sha256}/summary`, {
    headers: { "api-key": apiKey, "user-agent": "Falcon Sandbox", Accept: "application/json" },
    timeout: REQUEST_TIMEOUT_MS,
    validateStatus: () => true,
  });
  console.debug("[malwareIntel] Hybrid Analysis report response", report.data);
  if (report.status < 200 || report.status >= 300) {
    throw new Error(`Hybrid Analysis report failed (${report.status})`);
  }

  const verdictRaw = String(report.data?.verdict || report.data?.threat_level || report.data?.classification || "").toLowerCase();
  const verdict: MalwareVerdict = verdictRaw.includes("malicious")
    ? "MALICIOUS"
    : verdictRaw.includes("suspicious")
    ? "SUSPICIOUS"
    : "UNKNOWN";
  const riskScore = verdict === "MALICIOUS" ? 85 : verdict === "SUSPICIOUS" ? 55 : 0;

  return {
    provider: "HybridAnalysis",
    malicious: 0,
    suspicious: 0,
    harmless: 0,
    undetected: 0,
    riskScore,
    verdict,
    raw: report.data,
  };
};

const scanOPSWAT = async (filePath: string): Promise<ProviderResult> => {
  const baseUrl = getBaseUrl("opswat");
  const apiKey = getApiKey("opswat");
  if (!apiKey) throw new Error("OPSWAT API key missing");

  const form = new FormData();
  form.append("file", fs.createReadStream(filePath));

  console.info("[malwareIntel] OPSWAT upload", `${baseUrl}/file`);
  const upload = await axios.post(`${baseUrl}/file`, form, {
    headers: { ...form.getHeaders(), apikey: apiKey, Accept: "application/json" },
    timeout: REQUEST_TIMEOUT_MS,
    validateStatus: () => true,
  });
  console.debug("[malwareIntel] OPSWAT upload response", upload.data);
  if (upload.status < 200 || upload.status >= 300) {
    throw new Error(`OPSWAT upload failed (${upload.status})`);
  }

  const dataId = upload.data?.data_id;
  if (!dataId) throw new Error("OPSWAT missing data_id");

  for (let attempt = 0; attempt < MAX_POLL_ATTEMPTS; attempt += 1) {
    const report = await axios.get(`${baseUrl}/file/${dataId}`, {
      headers: { apikey: apiKey, Accept: "application/json" },
      timeout: REQUEST_TIMEOUT_MS,
      validateStatus: () => true,
    });
    console.debug("[malwareIntel] OPSWAT report response", report.data);
    if (report.status < 200 || report.status >= 300) {
      throw new Error(`OPSWAT report failed (${report.status})`);
    }

    const progress = report.data?.scan_results?.progress_percentage ?? 100;
    if (progress >= 100) {
      const details = report.data?.scan_results?.scan_details || {};
      return {
        provider: "OPSWAT",
        malicious: 0,
        suspicious: 0,
        harmless: 0,
        undetected: 0,
        riskScore: 0,
        verdict: "UNKNOWN",
        raw: report.data,
      };
    }

    await delay(POLL_DELAY_MS);
  }

  throw new Error("OPSWAT analysis polling timed out");
};

const runProviders = async (filePath: string) => {
  const providers = getProviders();
  const results: ProviderResult[] = [];

  for (const provider of providers) {
    try {
      if (provider === "virustotal") {
        results.push(await scanVirusTotal(filePath));
      } else if (provider === "hybrid" || provider === "hybrid-analysis") {
        results.push(await scanHybridAnalysis(filePath));
      } else if (provider === "opswat") {
        results.push(await scanOPSWAT(filePath));
      }
    } catch (error) {
      console.warn("[malwareIntel] Provider scan failed", { provider, error });
    }
  }

  return results;
};

const toMalwareIntelResult = (scan: ScanOutput): MalwareIntelResult => {
  return {
    found: true,
    verdict: scan.verdict,
    confidence: Math.max(0, Math.min(1, scan.confidence / 100)),
    maliciousCount: scan.maliciousCount,
    suspiciousCount: scan.suspiciousCount,
    harmlessCount: scan.harmlessCount,
    undetectedCount: scan.undetectedCount,
    riskScore: scan.riskScore,
    intelProvider: scan.intelProvider,
    malwareFamily: scan.malwareFamily,
    malwareType: scan.malwareType,
    threatLabel: scan.threatLabel,
    threatTags: scan.threatTags,
    md5: scan.md5,
    sha1: scan.sha1,
    fileSize: scan.fileSize,
    fileTypeDescription: scan.fileTypeDescription,
    entropy: scan.entropy,
    suspiciousStrings: scan.suspiciousStrings,
    detectionEngines: scan.detectionEngines,
    detectionTimestamp: scan.detectionTimestamp,
    behaviorDescription: scan.behaviorDescription,
    impactDescription: scan.impactDescription,
    mitigationSuggestions: scan.mitigationSuggestions,
    descriptionAm: scan.descriptionAm,
    iocs: scan.iocs,
    staticFeatures: scan.staticFeatures,
    dynamicFeatures: scan.dynamicFeatures,
    behaviorSummary: `Static analysis summary: ${scan.status} (${scan.confidence}%).`,
    classification: scan.verdict,
    behaviorIndicators: scan.reasons,
    targetPlatform: undefined,
    firstSeen: null,
    lastSeen: null,
    provider: scan.engineResults.provider,
  };
};

const scanFile = async (filePath: string): Promise<ScanOutput> => {
  if (!fs.existsSync(filePath)) {
    throw new Error("File not found");
  }

  const buffer = fs.readFileSync(filePath);
  const md5 = crypto.createHash("md5").update(buffer).digest("hex");
  const sha1 = crypto.createHash("sha1").update(buffer).digest("hex");
  const fileSize = buffer.length;
  const heuristic = runHeuristics(buffer, filePath);
  const archiveReport = heuristic.fileType === "archive" ? inspectArchive(buffer) : null;
  if (archiveReport) {
    archiveReport.reasons.forEach((reason) => heuristic.reasons.push(reason));
    if (archiveReport.encryptedEntries > 0) {
      heuristic.confidence = normalizePercent(heuristic.confidence + 30);
    }
    if (archiveReport.maxEntryScore > heuristic.confidence) {
      heuristic.confidence = normalizePercent(Math.max(heuristic.confidence, archiveReport.maxEntryScore));
    }
  }
  const providerResults = await runProviders(filePath);

  const malicious = providerResults.reduce((sum, r) => sum + r.malicious, 0);
  const suspicious = providerResults.reduce((sum, r) => sum + r.suspicious, 0);
  const harmless = providerResults.reduce((sum, r) => sum + r.harmless, 0);
  const undetected = providerResults.reduce((sum, r) => sum + r.undetected, 0);
  const counts: IntelCounts = { malicious, suspicious, harmless, undetected };
  const riskScore = computeRiskScore(counts);
  const externalVerdict = evaluateVerdictFromCounts(counts);

  const shouldSandbox = SANDBOX_ON_CLEAN
    && externalVerdict === "CLEAN"
    && (heuristic.confidence >= 45 || !!archiveReport?.suspiciousEntries || !!archiveReport?.encryptedEntries);

  const mlFeatures = buildMlFeatures({
    fileSize: buffer.length,
    fileType: fileTypeToNumber(heuristic.fileType),
    entropy: heuristic.metrics.entropy,
    isExecutable: heuristic.metrics.isExecutable ? 1 : 0,
    hasBase64: heuristic.metrics.hasBase64 ? 1 : 0,
    hasObfuscationStrings: heuristic.metrics.suspiciousStringCount > 0 ? 1 : 0,
    suspiciousStringCount: heuristic.metrics.suspiciousStringCount,
    sectionCount: heuristic.metrics.sectionCount,
    importCount: heuristic.metrics.importCount,
    vtMaliciousCount: malicious,
    vtSuspiciousCount: suspicious,
    numberOfEnginesScanned: providerResults.length,
    reputationScore: 100 - riskScore,
    heuristicScore: heuristic.confidence,
    indicatorCount: heuristic.metrics.indicatorCount,
  });

  const mlPrediction = riskScore < 70 ? predictMalwareRisk(mlFeatures) : null;

  const reasons = [...heuristic.reasons];
  if (providerResults.length) {
    providerResults.forEach((result) => {
      reasons.push(`${result.provider} detections: ${result.malicious} malicious, ${result.suspicious} suspicious.`);
    });
  } else {
    reasons.push("External intelligence unavailable; verdict based on static analysis.");
  }

  if (shouldSandbox && (SANDBOX_PROVIDER === "hybrid" || SANDBOX_PROVIDER === "hybrid-analysis")) {
    try {
      const sandboxResult = await scanHybridAnalysis(filePath);
      providerResults.push(sandboxResult);
      reasons.push(`Sandbox verdict: ${sandboxResult.provider} returned ${sandboxResult.verdict}.`);
    } catch (error) {
      console.warn("[malwareIntel] Sandbox analysis failed", { error });
    }
  }

  if (mlPrediction) {
    reasons.push(`ML risk score: ${mlPrediction.probability}%.`);
    if (mlPrediction.explanation.length) {
      reasons.push(`ML signals: ${mlPrediction.explanation.join("; ")}.`);
    }
  }

  const knownMalwareFamily = providerResults.find((result) => result.malwareFamily)?.malwareFamily;
  const knownMalwareType = providerResults.find((result) => result.malwareType)?.malwareType;
  const knownThreatLabel = providerResults.find((result) => result.threatLabel)?.threatLabel;
  const knownThreatTags = providerResults.find((result) => result.threatTags)?.threatTags;
  const knownFileTypeDescription = providerResults.find((result) => result.fileTypeDescription)?.fileTypeDescription;
  const knownDetectionEngines = providerResults.find((result) => result.detectionEngines)?.detectionEngines;
  const knownDetectionTimestamp = providerResults.find((result) => result.detectionTimestamp)?.detectionTimestamp;
  const typeProfile = resolveTypeProfile(knownMalwareType || knownThreatLabel || knownFileTypeDescription);
  const verdictDecision = evaluateVerdict({
    staticScore: heuristic.confidence,
    intelScore: riskScore,
    mlScore: mlPrediction?.probability ?? 0,
    indicators: reasons,
    knownMalwareFamily,
  });

  const finalReasons = verdictDecision.reasonSummary.length
    ? [...verdictDecision.reasonSummary, ...reasons]
    : reasons;

  const decisionVerdict: MalwareVerdict = verdictDecision.verdict === "Malicious"
    ? "MALICIOUS"
    : verdictDecision.verdict === "Suspicious"
    ? "SUSPICIOUS"
    : "CLEAN";

  const offlineScore = Math.max(heuristic.confidence, mlPrediction?.probability ?? 0);
  const offlineVerdict: MalwareVerdict = offlineScore >= 80
    ? "MALICIOUS"
    : offlineScore >= 45
    ? "SUSPICIOUS"
    : "CLEAN";

  if (!providerResults.length) {
    reasons.push(`Offline risk score: ${offlineScore}%.`);
  }

  const effectiveRiskScore = providerResults.length ? riskScore : offlineScore;
  const finalVerdict = providerResults.length
    ? heuristic.confidence >= 80
      ? "MALICIOUS"
      : heuristic.confidence >= 45 && externalVerdict === "CLEAN"
      ? "SUSPICIOUS"
      : externalVerdict
    : offlineVerdict;

  console.info("[malwareIntel] Final verdict", {
    verdict: finalVerdict,
    riskScore: effectiveRiskScore,
    counts,
  });

  return {
    status:
      finalVerdict === "MALICIOUS"
        ? "Malware Detected"
        : finalVerdict === "SUSPICIOUS"
        ? "Suspicious"
        : finalVerdict === "CLEAN"
        ? "Clean"
        : "Unknown",
    verdict: finalVerdict,
    confidence: normalizePercent(verdictDecision.confidence),
    analysisType: providerResults.length ? "combined" : "heuristic",
    fileType: heuristic.fileType,
    reasons: finalReasons,
    malwareFamily: knownMalwareFamily,
    malwareType: knownMalwareType,
    threatLabel: knownThreatLabel,
    threatTags: knownThreatTags,
    md5,
    sha1,
    fileSize,
    fileTypeDescription: knownFileTypeDescription,
    entropy: heuristic.metrics.entropy,
    suspiciousStrings: heuristic.suspiciousStrings,
    detectionEngines: knownDetectionEngines,
    detectionTimestamp: knownDetectionTimestamp,
    behaviorDescription: typeProfile.behavior,
    impactDescription: typeProfile.impact,
    mitigationSuggestions: typeProfile.mitigation,
    descriptionAm: typeProfile.am,
    iocs: {
      md5,
      sha1,
      sha256: computeSha256(buffer),
      tags: knownThreatTags || [],
    },
    staticFeatures: {
      entropy: heuristic.metrics.entropy,
      suspiciousStrings: heuristic.suspiciousStrings,
      fileType: heuristic.fileType,
      fileTypeDescription: knownFileTypeDescription,
      importCount: heuristic.metrics.importCount,
    },
    dynamicFeatures: {},
    maliciousCount: counts.malicious,
    suspiciousCount: counts.suspicious,
    harmlessCount: counts.harmless,
    undetectedCount: counts.undetected,
    riskScore: effectiveRiskScore,
    intelProvider: providerResults.map((r) => r.provider).join(", ") || "Heuristic/ML",
    engineResults: {
      provider: providerResults.length ? providerResults.map((r) => r.provider).join(", ") : "heuristic",
      malicious: providerResults.length ? malicious : heuristic.engineResults.malicious,
      suspicious: providerResults.length ? suspicious : heuristic.engineResults.suspicious,
    },
  };
};

export const uploadFileForAnalysis = async (buffer: Buffer, filename: string): Promise<MalwareIntelResult> => {
  const tempDir = path.join(process.cwd(), "uploads");
  fs.mkdirSync(tempDir, { recursive: true });
  const filePath = path.join(tempDir, `${Date.now()}-${filename}`);
  fs.writeFileSync(filePath, buffer);

  try {
    const scan = await scanFile(filePath);
    return toMalwareIntelResult(scan);
  } finally {
    fs.unlink(filePath, () => undefined);
  }
};

export const lookupHash = async (sha256: string): Promise<MalwareIntelResult> => {
  const apiKey = getApiKey("virustotal");
  if (!apiKey) {
    return { found: false, verdict: "UNKNOWN", confidence: 0 };
  }

  const baseUrl = getBaseUrl("virustotal");
  try {
    const res = await axios.get(`${baseUrl}/files/${sha256}`, {
      headers: { "x-apikey": apiKey, Accept: "application/json" },
      timeout: REQUEST_TIMEOUT_MS,
      validateStatus: () => true,
    });

    if (res.status === 404) {
      return { found: false, verdict: "UNKNOWN", confidence: 0 };
    }
    if (res.status < 200 || res.status >= 300) {
      throw new Error(`VirusTotal hash lookup failed (${res.status})`);
    }

    const intel = analyzeMalwareResult(res.data, "VirusTotal");
    const reasons = [
      `VirusTotal detections: malicious=${intel.counts.malicious}, suspicious=${intel.counts.suspicious}, harmless=${intel.counts.harmless}, undetected=${intel.counts.undetected}.`,
    ];

    const scan: ScanOutput = {
      status:
        intel.verdict === "MALICIOUS"
          ? "Malware Detected"
          : intel.verdict === "SUSPICIOUS"
          ? "Suspicious"
          : intel.verdict === "CLEAN"
          ? "Clean"
          : "Unknown",
      verdict: intel.verdict,
      confidence: intel.riskScore,
      analysisType: "external",
      fileType: "unknown",
      reasons,
      malwareFamily: intel.threatLabel || res.data?.data?.attributes?.popular_threat_classification?.suggested_threat_label,
      malwareType: intel.malwareType,
      threatLabel: intel.threatLabel,
      threatTags: intel.threatTags,
      md5: intel.md5,
      sha1: intel.sha1,
      fileSize: intel.fileSize,
      fileTypeDescription: intel.fileTypeDescription,
      detectionEngines: intel.detectionEngines,
      detectionTimestamp: intel.detectionTimestamp,
      maliciousCount: intel.counts.malicious,
      suspiciousCount: intel.counts.suspicious,
      harmlessCount: intel.counts.harmless,
      undetectedCount: intel.counts.undetected,
      riskScore: intel.riskScore,
      intelProvider: intel.intelProvider,
      engineResults: {
        provider: "VirusTotal",
        malicious: intel.counts.malicious,
        suspicious: intel.counts.suspicious,
      },
    };

    return toMalwareIntelResult(scan);
  } catch (error) {
    console.warn("[malwareIntel] Hash lookup failed", error);
    return { found: false, verdict: "UNKNOWN", confidence: 0 };
  }
};
