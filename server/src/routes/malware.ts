import { Router } from "express";
import rateLimit from "express-rate-limit";
import axios from "axios";
import multer from "multer";
import path from "path";
import { z } from "zod";
import { prisma } from "../prisma";
import { getDefaultTenantId } from "../utils/tenant";
import { appendAuditLog } from "../utils/audit";
import { requireAuth, requireRole } from "../auth";
import { analyzeMalwareResult, computeSha256, lookupHash, uploadFileForAnalysis } from "../utils/malwareIntel";
import { buildMalwareCsv, buildMalwarePdf, buildMalwareDetailPdf } from "../utils/malwareExport";
import type { MalwareScanRecord } from "../types/malware";

const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 25 * 1024 * 1024 },
});

const allowedExtensions = new Set([".exe", ".apk", ".pdf", ".docx", ".zip"]);
const allowedMimeTypes = new Set([
  "application/vnd.microsoft.portable-executable",
  "application/x-msdownload",
  "application/vnd.android.package-archive",
  "application/pdf",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/zip",
  "application/x-zip-compressed",
]);

const resolvePlatform = (ext: string, mime: string, targetPlatform?: string | null) => {
  if (targetPlatform) return targetPlatform;
  if ([".exe"].includes(ext)) return "windows";
  if ([".apk"].includes(ext)) return "android";
  if ([".pdf"].includes(ext) || mime === "application/pdf") return "pdf";
  if ([".zip"].includes(ext) || mime.includes("zip")) return "archive";
  return "unknown";
};

const tagSchema = z.object({
  deliveryMethod: z.string().max(50).optional(),
  impersonatedInstitution: z.string().max(80).optional(),
});

const sanitizeVerdict = (verdict: string) => {
  if (verdict === "MALWARE") return "Malware Detected";
  if (verdict === "POTENTIALLY_MALICIOUS") return "Suspicious";
  if (verdict === "MALICIOUS") return "Malware Detected";
  if (verdict === "SUSPICIOUS") return "Suspicious";
  if (verdict === "UNKNOWN") return "Unknown";
  return "Clean";
};

const resolveConfidenceBand = (confidenceScore: number) => {
  if (confidenceScore <= 20) return "safe" as const;
  if (confidenceScore <= 70) return "suspicious" as const;
  return "malware" as const;
};

const resolveBandLabels = (band: "safe" | "suspicious" | "malware") => {
  if (band === "malware") {
    return { label: "Malware Detected", labelAm: "ማልዌር ተገኘ" };
  }
  if (band === "suspicious") {
    return { label: "Suspicious", labelAm: "ጥርጣሬ ያለ" };
  }
  return { label: "Safe / Low confidence", labelAm: "ደህንነት / ዝቅተኛ እምነት" };
};

export const malwareRouter = Router();
export const adminMalwareRouter = Router();
adminMalwareRouter.use(requireAuth);

type VerdictKey = "CLEAN" | "SUSPICIOUS" | "MALICIOUS" | "UNKNOWN";
type VerdictCounts = Record<VerdictKey, number>;
type MalwareStatsPayload = {
  total: number;
  verdicts: VerdictCounts;
  averageRiskScore: number;
  highRiskScans: number;
  intelProviders: Array<{ provider: string; count: number }>;
  topFamilies: Array<{ name: string; count: number }>;
  topTypes: Array<{ name: string; count: number }>;
  topThreatLabels: Array<{ name: string; count: number }>;
  trends: {
    daily: Array<{ date: string; counts: VerdictCounts }>;
    weekly: Array<{ weekStart: string; counts: VerdictCounts }>;
  };
  lastUpdated: string;
};

const statsCache = new Map<string, { expiresAt: number; payload: MalwareStatsPayload }>();

const emptyVerdictCounts = (): VerdictCounts => ({
  CLEAN: 0,
  SUSPICIOUS: 0,
  MALICIOUS: 0,
  UNKNOWN: 0,
});

const resolveVerdictKey = (value: string): VerdictKey => {
  if (value === "CLEAN") return "CLEAN";
  if (value === "POTENTIALLY_MALICIOUS") return "SUSPICIOUS";
  if (value === "MALWARE") return "MALICIOUS";
  if (value === "SUSPICIOUS") return "SUSPICIOUS";
  if (value === "MALICIOUS") return "MALICIOUS";
  return "UNKNOWN";
};

const deriveVerdictKey = (scan: { verdict: string; riskScore?: number | null; confidenceScore?: number | null }): VerdictKey => {
  const normalized = resolveVerdictKey(scan.verdict);
  if (normalized !== "UNKNOWN") return normalized;
  const scoreRaw = Number.isFinite(scan.riskScore) ? scan.riskScore : scan.confidenceScore;
  const score = Number.isFinite(scoreRaw as number) ? (scoreRaw as number) : 0;
  if (score >= 80) return "MALICIOUS";
  if (score >= 45) return "SUSPICIOUS";
  if (score > 0) return "CLEAN";
  return "UNKNOWN";
};

const rescanLimiter = rateLimit({
  windowMs: 10 * 60 * 1000,
  max: 20,
  standardHeaders: true,
  legacyHeaders: false,
});

malwareRouter.post("/api/malware/scan", upload.single("file"), async (req, res) => {
  const file = req.file;
  if (!file) return res.status(400).json({ error: "No file provided" });

  const ext = path.extname(file.originalname).toLowerCase();
  if (!allowedExtensions.has(ext)) {
    return res.status(400).json({ error: "Unsupported file type" });
  }
  if (!allowedMimeTypes.has(file.mimetype)) {
    return res.status(400).json({ error: "Unsupported MIME type" });
  }

  const tagParsed = tagSchema.safeParse(req.body || {});
  if (!tagParsed.success) {
    return res.status(400).json({ error: "Invalid metadata", details: tagParsed.error.flatten() });
  }

  try {
    const tenantId = await getDefaultTenantId();
    const hashSha256 = computeSha256(file.buffer);

    let intel = await lookupHash(hashSha256);
    if (!intel.found) {
      intel = await uploadFileForAnalysis(file.buffer, file.originalname);
    }

    const verdict = intel.verdict;
    const confidenceScore = Math.round((intel.confidence || 0) * 100);
    const statusLabel = intel.classification || sanitizeVerdict(verdict);
    const confidenceBand = statusLabel === "Malware Detected"
      ? "malware"
      : statusLabel === "Suspicious" || statusLabel === "Unknown"
      ? "suspicious"
      : "safe";
    const bandLabels = resolveBandLabels(confidenceBand);
    const now = new Date();

    const record = await prisma.malwareScan.upsert({
      where: { tenantId_hashSha256: { tenantId, hashSha256 } },
      update: {
        fileName: file.originalname,
        fileType: file.mimetype,
        source: tagParsed.data.deliveryMethod || "upload",
        platform: resolvePlatform(ext, file.mimetype, intel.targetPlatform),
        verdict,
        scanCount: { increment: 1 },
        confidenceScore,
        maliciousCount: intel.maliciousCount,
        suspiciousCount: intel.suspiciousCount,
        harmlessCount: intel.harmlessCount,
        undetectedCount: intel.undetectedCount,
        riskScore: intel.riskScore,
        malwareFamily: intel.malwareFamily,
        malwareType: intel.malwareType,
        threatLabel: intel.threatLabel,
        threatTagsJson: intel.threatTags ? JSON.stringify(intel.threatTags) : null,
        md5: intel.md5,
        sha1: intel.sha1,
        fileSize: intel.fileSize,
        fileTypeDescription: intel.fileTypeDescription,
        detectionEnginesJson: intel.detectionEngines ? JSON.stringify(intel.detectionEngines) : null,
        detectionTimestamp: intel.detectionTimestamp ?? undefined,
        behaviorDescription: intel.behaviorDescription,
        impactDescription: intel.impactDescription,
        mitigationSuggestions: intel.mitigationSuggestions,
        descriptionAm: intel.descriptionAm,
        iocsJson: intel.iocs ? JSON.stringify(intel.iocs) : null,
        staticFeaturesJson: intel.staticFeatures ? JSON.stringify(intel.staticFeatures) : null,
        dynamicFeaturesJson: intel.dynamicFeatures ? JSON.stringify(intel.dynamicFeatures) : null,
        behaviorSummary: intel.behaviorSummary,
        targetPlatform: intel.targetPlatform,
        deliveryMethod: tagParsed.data.deliveryMethod,
        impersonatedInstitution: tagParsed.data.impersonatedInstitution,
        classification: intel.classification,
        behaviorIndicatorsJson: intel.behaviorIndicators ? JSON.stringify(intel.behaviorIndicators) : null,
        sourceProvider: intel.provider,
        intelProvider: intel.intelProvider,
        lastSeen: intel.lastSeen ?? now,
      } as any,
      create: {
        tenantId,
        hashSha256,
        fileName: file.originalname,
        fileType: file.mimetype,
        source: tagParsed.data.deliveryMethod || "upload",
        platform: resolvePlatform(ext, file.mimetype, intel.targetPlatform),
        verdict,
        scanCount: 1,
        confidenceScore,
        maliciousCount: intel.maliciousCount,
        suspiciousCount: intel.suspiciousCount,
        harmlessCount: intel.harmlessCount,
        undetectedCount: intel.undetectedCount,
        riskScore: intel.riskScore,
        malwareFamily: intel.malwareFamily,
        malwareType: intel.malwareType,
        threatLabel: intel.threatLabel,
        threatTagsJson: intel.threatTags ? JSON.stringify(intel.threatTags) : null,
        md5: intel.md5,
        sha1: intel.sha1,
        fileSize: intel.fileSize,
        fileTypeDescription: intel.fileTypeDescription,
        detectionEnginesJson: intel.detectionEngines ? JSON.stringify(intel.detectionEngines) : null,
        detectionTimestamp: intel.detectionTimestamp ?? undefined,
        behaviorDescription: intel.behaviorDescription,
        impactDescription: intel.impactDescription,
        mitigationSuggestions: intel.mitigationSuggestions,
        descriptionAm: intel.descriptionAm,
        iocsJson: intel.iocs ? JSON.stringify(intel.iocs) : null,
        staticFeaturesJson: intel.staticFeatures ? JSON.stringify(intel.staticFeatures) : null,
        dynamicFeaturesJson: intel.dynamicFeatures ? JSON.stringify(intel.dynamicFeatures) : null,
        behaviorSummary: intel.behaviorSummary,
        targetPlatform: intel.targetPlatform,
        deliveryMethod: tagParsed.data.deliveryMethod,
        impersonatedInstitution: tagParsed.data.impersonatedInstitution,
        classification: intel.classification,
        behaviorIndicatorsJson: intel.behaviorIndicators ? JSON.stringify(intel.behaviorIndicators) : null,
        sourceProvider: intel.provider,
        intelProvider: intel.intelProvider,
        firstSeen: intel.firstSeen ?? now,
        lastSeen: intel.lastSeen ?? now,
      } as any,
    });

    await appendAuditLog({
      tenantId,
      action: "malware.scan",
      targetType: "MalwareScan",
      targetId: record.id,
      metadata: { verdict: record.verdict, confidenceScore: record.confidenceScore },
    });

    const warning = verdict === "MALICIOUS"
      ? "⚠️ This file is malicious. Do NOT open or share it."
      : verdict === "SUSPICIOUS"
      ? "Treat this file with caution and confirm the source before opening."
      : undefined;

    return res.json({
      verdict,
      verdictLabel: statusLabel,
      verdictLabelAm: bandLabels.labelAm,
      confidenceBand,
      confidence: record.confidenceScore,
      malwareFamily: record.malwareFamily || undefined,
      behaviorSummary: record.behaviorSummary || "Static analysis summary unavailable.",
      warning,
      sourceLabel: "External Malware Intelligence Result",
    });
  } catch (err: any) {
    return res.status(502).json({
      error: "External Malware Intelligence Result unavailable. Please try again later.",
    });
  }
});

adminMalwareRouter.get("/malware/scans", requireRole("analyst"), async (req, res) => {
  try {
    const tenantId = (req as any).user.tenantId;
    const verdict = req.query.verdict ? String(req.query.verdict) : undefined;
    const scans = (await prisma.malwareScan.findMany({
      where: {
        tenantId,
        ...(verdict ? { verdict } : {}),
      },
      orderBy: { createdAt: "desc" },
      take: 100,
    })) as MalwareScanRecord[];

    return res.json({
      data: scans.map((scan: MalwareScanRecord) => ({
        ...scan,
        verdict: deriveVerdictKey(scan),
        threatTags: scan.threatTagsJson ? JSON.parse(scan.threatTagsJson) : [],
        suspiciousStrings: scan.suspiciousStringsJson ? JSON.parse(scan.suspiciousStringsJson) : [],
        detectionEngines: scan.detectionEnginesJson ? JSON.parse(scan.detectionEnginesJson) : [],
        iocs: scan.iocsJson ? JSON.parse(scan.iocsJson) : null,
        staticFeatures: scan.staticFeaturesJson ? JSON.parse(scan.staticFeaturesJson) : null,
        dynamicFeatures: scan.dynamicFeaturesJson ? JSON.parse(scan.dynamicFeaturesJson) : null,
        behaviorIndicators: scan.behaviorIndicatorsJson ? JSON.parse(scan.behaviorIndicatorsJson) : [],
      })),
    });
  } catch (err) {
    return res.status(500).json({ error: "Failed to load malware scans" });
  }
});

adminMalwareRouter.post("/malware/:id/rescan", requireRole("analyst"), rescanLimiter, async (req, res) => {
  const tenantId = (req as any).user.tenantId as string;
  const scanId = req.params.id;
  const now = new Date();

  const scan = (await prisma.malwareScan.findFirst({ where: { id: scanId, tenantId } })) as MalwareScanRecord | null;
  if (!scan) {
    return res.status(404).json({ error: "Malware scan not found" });
  }

  const previous = { verdict: scan.verdict, riskScore: scan.riskScore };
  const baseUrl = process.env.MALWARE_INTEL_BASE_URL || "https://www.virustotal.com/api/v3";
  const apiKey = process.env.MALWARE_INTEL_API_KEY;

  if (!apiKey) {
    await prisma.malwareScan.update({
      where: { id: scan.id },
      data: { lastCheckedAt: now } as any,
    });
    await appendAuditLog({
      tenantId,
      action: "malware.rescan",
      targetType: "MalwareScan",
      targetId: scan.id,
      metadata: { previous, outcome: "intel_unavailable" },
    });
    return res.json({ ok: false, message: "Intel unavailable, verdict unchanged" });
  }

  try {
    const response = await axios.get(`${baseUrl}/files/${scan.hashSha256}`, {
      headers: { "x-apikey": apiKey, Accept: "application/json" },
      timeout: 20000,
      validateStatus: () => true,
    });

    if (response.status !== 200) {
      await prisma.malwareScan.update({
        where: { id: scan.id },
        data: { lastCheckedAt: now } as any,
      });
      await appendAuditLog({
        tenantId,
        action: "malware.rescan",
        targetType: "MalwareScan",
        targetId: scan.id,
        metadata: { previous, outcome: "intel_unavailable", status: response.status },
      });
      return res.json({ ok: false, message: "Intel unavailable, verdict unchanged" });
    }

    const intel = analyzeMalwareResult(response.data, "VirusTotal");
    const verdict = intel.verdict;

    await prisma.malwareScan.update({
      where: { id: scan.id },
      data: {
        verdict,
        scanCount: { increment: 1 },
        confidenceScore: intel.riskScore,
        riskScore: intel.riskScore,
        maliciousCount: intel.counts.malicious,
        suspiciousCount: intel.counts.suspicious,
        harmlessCount: intel.counts.harmless,
        undetectedCount: intel.counts.undetected,
        intelProvider: intel.intelProvider,
        malwareType: intel.malwareType,
        threatLabel: intel.threatLabel,
        threatTagsJson: intel.threatTags ? JSON.stringify(intel.threatTags) : null,
        md5: intel.md5,
        sha1: intel.sha1,
        fileSize: intel.fileSize,
        fileTypeDescription: intel.fileTypeDescription,
        detectionEnginesJson: intel.detectionEngines ? JSON.stringify(intel.detectionEngines) : null,
        detectionTimestamp: intel.detectionTimestamp ?? undefined,
        behaviorDescription: intel.behaviorDescription,
        impactDescription: intel.impactDescription,
        mitigationSuggestions: intel.mitigationSuggestions,
        descriptionAm: intel.descriptionAm,
        iocsJson: intel.iocs ? JSON.stringify(intel.iocs) : null,
        staticFeaturesJson: intel.staticFeatures ? JSON.stringify(intel.staticFeatures) : null,
        dynamicFeaturesJson: intel.dynamicFeatures ? JSON.stringify(intel.dynamicFeatures) : null,
        classification: verdict,
        lastCheckedAt: now,
      } as any,
    });

    console.info("[malware.rescan] verdict update", {
      scanId: scan.id,
      previous,
      next: { verdict, riskScore: intel.riskScore },
    });

    await appendAuditLog({
      tenantId,
      action: "malware.rescan",
      targetType: "MalwareScan",
      targetId: scan.id,
      metadata: {
        previous,
        next: { verdict, riskScore: intel.riskScore },
        provider: intel.intelProvider,
      },
    });

    return res.json({
      ok: true,
      verdict,
      riskScore: intel.riskScore,
      changed: previous.verdict !== verdict || previous.riskScore !== intel.riskScore,
      message: "Re-analysis completed",
    });
  } catch (error) {
    console.warn("[malware.rescan] intel error", error);
    await prisma.malwareScan.update({
      where: { id: scan.id },
      data: { lastCheckedAt: now } as any,
    });
    await appendAuditLog({
      tenantId,
      action: "malware.rescan",
      targetType: "MalwareScan",
      targetId: scan.id,
      metadata: { previous, outcome: "intel_error" },
    });
    return res.json({ ok: false, message: "Intel unavailable, verdict unchanged" });
  }
});

adminMalwareRouter.get("/malware-scans", requireRole("analyst"), async (req, res) => {
  const parsed = z
    .object({
      page: z.coerce.number().int().min(1).default(1),
      limit: z.coerce.number().int().min(1).max(100).default(10),
      verdict: z.enum(["CLEAN", "SUSPICIOUS", "MALICIOUS", "UNKNOWN"]).optional(),
      platform: z.enum(["windows", "android", "pdf", "archive", "unknown"]).optional(),
      from: z.coerce.date().optional(),
      to: z.coerce.date().optional(),
    })
    .safeParse(req.query);

  if (!parsed.success) {
    return res.status(400).json({ error: "Invalid query", details: parsed.error.flatten() });
  }

  try {
    const tenantId = (req as any).user.tenantId;
    const { page, limit, verdict, platform, from, to } = parsed.data;
    const where: any = { tenantId };
    if (verdict) where.verdict = verdict;
    if (platform) where.platform = platform;
    if (from || to) {
      where.createdAt = {};
      if (from) where.createdAt.gte = from;
      if (to) where.createdAt.lte = to;
    }

    const [total, rows] = await Promise.all([
      prisma.malwareScan.count({ where }),
      prisma.malwareScan.findMany({
        where,
        orderBy: { createdAt: "desc" },
        skip: (page - 1) * limit,
        take: limit,
      }),
    ]);

    return res.json({
      total,
      rows: (rows as MalwareScanRecord[]).map((scan) => ({
        id: scan.id,
        fileName: scan.fileName,
        fileHash: scan.hashSha256,
        verdict: deriveVerdictKey(scan),
        malwareFamily: scan.malwareFamily,
        malwareType: scan.malwareType,
        threatLabel: scan.threatLabel,
        threatTags: scan.threatTagsJson ? JSON.parse(scan.threatTagsJson) : [],
        md5: scan.md5,
        sha1: scan.sha1,
        fileSize: scan.fileSize,
        fileTypeDescription: scan.fileTypeDescription,
        entropy: scan.entropy,
        suspiciousStrings: scan.suspiciousStringsJson ? JSON.parse(scan.suspiciousStringsJson) : [],
        detectionEngines: scan.detectionEnginesJson ? JSON.parse(scan.detectionEnginesJson) : [],
        detectionTimestamp: scan.detectionTimestamp?.toISOString(),
        behaviorDescription: scan.behaviorDescription,
        impactDescription: scan.impactDescription,
        mitigationSuggestions: scan.mitigationSuggestions,
        descriptionAm: scan.descriptionAm,
        iocs: scan.iocsJson ? JSON.parse(scan.iocsJson) : null,
        staticFeatures: scan.staticFeaturesJson ? JSON.parse(scan.staticFeaturesJson) : null,
        dynamicFeatures: scan.dynamicFeaturesJson ? JSON.parse(scan.dynamicFeaturesJson) : null,
        confidenceScore: scan.confidenceScore,
        riskScore: scan.riskScore,
        maliciousCount: scan.maliciousCount,
        suspiciousCount: scan.suspiciousCount,
        harmlessCount: scan.harmlessCount,
        intelProvider: scan.intelProvider || scan.sourceProvider || "External Intel",
        platform: scan.platform || "unknown",
        fileType: scan.fileType,
        source: scan.source || "upload",
        createdAt: scan.createdAt,
        scannedAt: scan.createdAt,
      })),
    });
  } catch (err) {
    return res.status(500).json({ error: "Failed to load malware scans" });
  }
});

adminMalwareRouter.get("/malware/stats", requireRole("analyst"), async (req, res) => {
  try {
    const tenantId = (req as any).user.tenantId as string;
    const refresh = req.query.refresh === "1";
    const cached = statsCache.get(tenantId);
    if (!refresh && cached && cached.expiresAt > Date.now() && cached.payload.total > 0) {
      return res.json(cached.payload);
    }

    const now = new Date();
    const start30 = new Date(now);
    start30.setDate(start30.getDate() - 29);
    const start12Weeks = new Date(now);
    start12Weeks.setDate(start12Weeks.getDate() - 7 * 12 + 1);

    const scans = (await prisma.malwareScan.findMany({
      where: { tenantId },
    })) as MalwareScanRecord[];

    let total = 0;
    const verdicts: VerdictCounts = emptyVerdictCounts();
    const providerTotals = new Map<string, number>();
    const familyTotals = new Map<string, number>();
    const typeTotals = new Map<string, number>();
    const labelTotals = new Map<string, number>();
    let riskSum = 0;
    let riskCount = 0;
    let highRiskCount = 0;

    scans.forEach((scan) => {
      const weight = Math.max(1, scan.scanCount || 1);
      total += weight;
      const derivedVerdict = deriveVerdictKey(scan);
      verdicts[derivedVerdict] += weight;

      const provider = scan.intelProvider || "External Intel";
      providerTotals.set(provider, (providerTotals.get(provider) || 0) + weight);

      if (scan.malwareFamily) {
        familyTotals.set(scan.malwareFamily, (familyTotals.get(scan.malwareFamily) || 0) + weight);
      }
      if (scan.malwareType) {
        typeTotals.set(scan.malwareType, (typeTotals.get(scan.malwareType) || 0) + weight);
      }
      if (scan.threatLabel) {
        labelTotals.set(scan.threatLabel, (labelTotals.get(scan.threatLabel) || 0) + weight);
      }

      const scoreRaw = Number.isFinite(scan.riskScore) ? scan.riskScore : scan.confidenceScore;
      const score = Number.isFinite(scoreRaw as number) ? (scoreRaw as number) : null;
      if (score !== null) {
        riskSum += score * weight;
        riskCount += weight;
        if (score >= 70) highRiskCount += weight;
      }
    });

    const intelProviders = Array.from(providerTotals.entries()).map(([provider, count]) => ({
      provider,
      count,
    }));

    const buildTopList = (source: Map<string, number>, limit = 6) =>
      Array.from(source.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, limit)
        .map(([name, count]) => ({ name, count }));

    const topFamilies = buildTopList(familyTotals);
    const topTypes = buildTopList(typeTotals);
    const topThreatLabels = buildTopList(labelTotals);

    const dayBuckets = new Map<string, VerdictCounts>();
    const weekBuckets = new Map<string, VerdictCounts>();

    scans
      .filter((scan) => scan.createdAt >= start12Weeks)
      .forEach((scan) => {
      const date = scan.lastCheckedAt || scan.createdAt;
      const dayKey = date.toISOString().slice(0, 10);
      const weekStart = new Date(date);
      const day = weekStart.getUTCDay();
      const diff = (day === 0 ? -6 : 1) - day;
      weekStart.setUTCDate(weekStart.getUTCDate() + diff);
      const weekKey = weekStart.toISOString().slice(0, 10);

      if (!dayBuckets.has(dayKey)) dayBuckets.set(dayKey, emptyVerdictCounts());
      if (!weekBuckets.has(weekKey)) weekBuckets.set(weekKey, emptyVerdictCounts());

      const verdict = deriveVerdictKey(scan);
      dayBuckets.get(dayKey)![verdict] += 1;
      weekBuckets.get(weekKey)![verdict] += 1;
    });

    const buildDailySeries = () => {
      const series: Array<{ date: string; counts: VerdictCounts }> = [];
      for (let i = 0; i < 30; i += 1) {
        const date = new Date(start30);
        date.setDate(start30.getDate() + i);
        const key = date.toISOString().slice(0, 10);
        series.push({ date: key, counts: dayBuckets.get(key) || emptyVerdictCounts() });
      }
      return series;
    };

    const buildWeeklySeries = () => {
      const series: Array<{ weekStart: string; counts: VerdictCounts }> = [];
      for (let i = 0; i < 12; i += 1) {
        const date = new Date(start12Weeks);
        date.setDate(start12Weeks.getDate() + i * 7);
        const key = date.toISOString().slice(0, 10);
        series.push({ weekStart: key, counts: weekBuckets.get(key) || emptyVerdictCounts() });
      }
      return series;
    };

    const payload: MalwareStatsPayload = {
      total,
      verdicts,
      averageRiskScore: Math.round(riskCount ? riskSum / riskCount : 0),
      highRiskScans: highRiskCount,
      intelProviders,
      topFamilies,
      topTypes,
      topThreatLabels,
      trends: {
        daily: buildDailySeries(),
        weekly: buildWeeklySeries(),
      },
      lastUpdated: now.toISOString(),
    };

    if (payload.total > 0) {
      statsCache.set(tenantId, { expiresAt: Date.now() + 15_000, payload });
    }
    return res.json(payload);
  } catch (err) {
    return res.status(500).json({ error: "Failed to load malware stats" });
  }
});

adminMalwareRouter.get("/malware/exports/csv", requireRole("analyst"), async (req, res) => {
  try {
    const tenantId = (req as any).user.tenantId;
    const records = (await prisma.malwareScan.findMany({ where: { tenantId }, orderBy: { createdAt: "desc" } })) as MalwareScanRecord[];
    const csv = buildMalwareCsv(records);
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", `attachment; filename="phishguard-malware-${Date.now()}.csv"`);
    return res.send(csv);
  } catch (err) {
    return res.status(500).json({ error: "Failed to export malware CSV" });
  }
});

adminMalwareRouter.get("/malware/exports/pdf", requireRole("analyst"), async (req, res) => {
  try {
    const tenantId = (req as any).user.tenantId;
    const records = (await prisma.malwareScan.findMany({ where: { tenantId }, orderBy: { createdAt: "desc" } })) as MalwareScanRecord[];
    const doc = buildMalwarePdf(records);
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename="phishguard-malware-${Date.now()}.pdf"`);
    doc.pipe(res);
    doc.end();
  } catch (err) {
    return res.status(500).json({ error: "Failed to export malware PDF" });
  }
});

adminMalwareRouter.get("/malware/exports/:id/pdf", requireRole("analyst"), async (req, res) => {
  try {
    const tenantId = (req as any).user.tenantId as string;
    const scan = (await prisma.malwareScan.findFirst({
      where: { id: req.params.id, tenantId },
    })) as MalwareScanRecord | null;

    if (!scan) {
      return res.status(404).json({ error: "Malware scan not found" });
    }

    const doc = buildMalwareDetailPdf(scan);
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename=malware-${scan.id}.pdf`);
    doc.pipe(res);
    doc.end();
  } catch (err) {
    return res.status(500).json({ error: "Failed to export malware PDF" });
  }
});
